.TH "include/liblvgl/core/lv_indev.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/core/lv_indev.h
.SH SYNOPSIS
.br
.PP
\fR#include 'lv_obj\&.h'\fP
.br
\fR#include 'liblvgl/hal/lv_hal_indev\&.h'\fP
.br
\fR#include 'lv_group\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlv_indev_read_timer_cb\fP (\fBlv_timer_t\fP *timer)"
.br
.ti -1c
.RI "void \fBlv_indev_enable\fP (\fBlv_indev_t\fP *indev, bool en)"
.br
.ti -1c
.RI "\fBlv_indev_t\fP * \fBlv_indev_get_act\fP (void)"
.br
.ti -1c
.RI "\fBlv_indev_type_t\fP \fBlv_indev_get_type\fP (const \fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "void \fBlv_indev_reset\fP (\fBlv_indev_t\fP *indev, lv_obj_t *obj)"
.br
.ti -1c
.RI "void \fBlv_indev_reset_long_press\fP (\fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "void \fBlv_indev_set_cursor\fP (\fBlv_indev_t\fP *indev, lv_obj_t *cur_obj)"
.br
.ti -1c
.RI "void \fBlv_indev_set_group\fP (\fBlv_indev_t\fP *indev, \fBlv_group_t\fP *group)"
.br
.ti -1c
.RI "void \fBlv_indev_set_button_points\fP (\fBlv_indev_t\fP *indev, const \fBlv_point_t\fP points[])"
.br
.ti -1c
.RI "void \fBlv_indev_get_point\fP (const \fBlv_indev_t\fP *indev, \fBlv_point_t\fP *point)"
.br
.ti -1c
.RI "lv_dir_t \fBlv_indev_get_gesture_dir\fP (const \fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "uint32_t \fBlv_indev_get_key\fP (const \fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "lv_dir_t \fBlv_indev_get_scroll_dir\fP (const \fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "lv_obj_t * \fBlv_indev_get_scroll_obj\fP (const \fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "void \fBlv_indev_get_vect\fP (const \fBlv_indev_t\fP *indev, \fBlv_point_t\fP *point)"
.br
.ti -1c
.RI "void \fBlv_indev_wait_release\fP (\fBlv_indev_t\fP *indev)"
.br
.ti -1c
.RI "lv_obj_t * \fBlv_indev_get_obj_act\fP (void)"
.br
.ti -1c
.RI "\fBlv_timer_t\fP * \fBlv_indev_get_read_timer\fP (\fBlv_disp_t\fP *indev)"
.br
.ti -1c
.RI "lv_obj_t * \fBlv_indev_search_obj\fP (lv_obj_t *obj, \fBlv_point_t\fP *point)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void lv_indev_enable (\fBlv_indev_t\fP * indev, bool en)"
Enable or disable one or all input devices (default enabled) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device or NULL to enable/disable all of them 
.br
\fIen\fP true to enable, false to disable 
.RE
.PP

.SS "\fBlv_indev_t\fP * lv_indev_get_act (void )"
Get the currently processed input device\&. Can be used in action functions too\&. 
.PP
\fBReturns\fP
.RS 4
pointer to the currently processed input device or NULL if no input device processing right now 
.RE
.PP

.SS "lv_dir_t lv_indev_get_gesture_dir (const \fBlv_indev_t\fP * indev)"
Get the current gesture direct 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP
\fBReturns\fP
.RS 4
current gesture direct 
.RE
.PP

.SS "uint32_t lv_indev_get_key (const \fBlv_indev_t\fP * indev)"
Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP
\fBReturns\fP
.RS 4
the last pressed key (0 on error) 
.RE
.PP

.SS "lv_obj_t * lv_indev_get_obj_act (void )"
Gets a pointer to the currently active object in the currently processed input device\&. 
.PP
\fBReturns\fP
.RS 4
pointer to currently active object or NULL if no active object 
.RE
.PP

.SS "void lv_indev_get_point (const \fBlv_indev_t\fP * indev, \fBlv_point_t\fP * point)"
Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.br
\fIpoint\fP pointer to a point to store the result 
.RE
.PP

.SS "\fBlv_timer_t\fP * lv_indev_get_read_timer (\fBlv_disp_t\fP * indev)"
Get a pointer to the indev read timer to modify its parameters with \fRlv_timer_\&.\&.\&.\fP functions\&. 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the indev read refresher timer\&. (NULL on error) 
.RE
.PP

.SS "lv_dir_t lv_indev_get_scroll_dir (const \fBlv_indev_t\fP * indev)"
Check the current scroll direction of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP
\fBReturns\fP
.RS 4
LV_DIR_NONE: no scrolling now LV_DIR_HOR/VER 
.RE
.PP

.SS "lv_obj_t * lv_indev_get_scroll_obj (const \fBlv_indev_t\fP * indev)"
Get the currently scrolled object (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the currently scrolled object or NULL if no scrolling by this indev 
.RE
.PP

.SS "\fBlv_indev_type_t\fP lv_indev_get_type (const \fBlv_indev_t\fP * indev)"
Get the type of an input device 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP
\fBReturns\fP
.RS 4
the type of the input device from \fRlv_hal_indev_type_t\fP (\fRLV_INDEV_TYPE_\&.\&.\&.\fP) 
.RE
.PP

.SS "void lv_indev_get_vect (const \fBlv_indev_t\fP * indev, \fBlv_point_t\fP * point)"
Get the movement vector of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.br
\fIpoint\fP pointer to a point to store the types\&.pointer\&.vector 
.RE
.PP

.SS "void lv_indev_read_timer_cb (\fBlv_timer_t\fP * timer)"
Called periodically to read the input devices 
.PP
\fBParameters\fP
.RS 4
\fItimer\fP pointer to a timer to read 
.RE
.PP

.SS "void lv_indev_reset (\fBlv_indev_t\fP * indev, lv_obj_t * obj)"
Reset one or all input devices 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device to reset or NULL to reset all of them 
.br
\fIobj\fP pointer to an object which triggers the reset\&. 
.RE
.PP

.SS "void lv_indev_reset_long_press (\fBlv_indev_t\fP * indev)"
Reset the long press state of an input device 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP

.SS "lv_obj_t * lv_indev_search_obj (lv_obj_t * obj, \fBlv_point_t\fP * point)"
Search the most top, clickable object by a point 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a start object, typically the screen 
.br
\fIpoint\fP pointer to a point for searching the most top child 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the found object or NULL if there was no suitable object 
.RE
.PP

.SS "void lv_indev_set_button_points (\fBlv_indev_t\fP * indev, const \fBlv_point_t\fP points[])"
Set the an array of points for LV_INDEV_TYPE_BUTTON\&. These points will be assigned to the buttons to press a specific point on the screen 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.br
\fIgroup\fP point to a group 
.RE
.PP

.SS "void lv_indev_set_cursor (\fBlv_indev_t\fP * indev, lv_obj_t * cur_obj)"
Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.br
\fIcur_obj\fP pointer to an object to be used as cursor 
.RE
.PP

.SS "void lv_indev_set_group (\fBlv_indev_t\fP * indev, \fBlv_group_t\fP * group)"
Set a destination group for a keypad input device (for LV_INDEV_TYPE_KEYPAD) 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.br
\fIgroup\fP point to a group 
.RE
.PP

.SS "void lv_indev_wait_release (\fBlv_indev_t\fP * indev)"
Do nothing until the next release 
.PP
\fBParameters\fP
.RS 4
\fIindev\fP pointer to an input device 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
