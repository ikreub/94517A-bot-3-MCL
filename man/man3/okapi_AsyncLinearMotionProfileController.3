.TH "okapi::AsyncLinearMotionProfileController" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
okapi::AsyncLinearMotionProfileController
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBokapi::AsyncPositionController< std::string, double >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAsyncLinearMotionProfileController\fP (const \fBTimeUtil\fP &itimeUtil, const \fBPathfinderLimits\fP &ilimits, const std::shared_ptr< \fBControllerOutput\fP< double > > &ioutput, const QLength &idiameter, const \fBAbstractMotor::GearsetRatioPair\fP &ipair, const std::shared_ptr< \fBLogger\fP > &ilogger=\fBLogger::getDefaultLogger\fP())"
.br
.ti -1c
.RI "\fBAsyncLinearMotionProfileController\fP (AsyncLinearMotionProfileController &&other)=delete"
.br
.ti -1c
.RI "\fBAsyncLinearMotionProfileController\fP & \fBoperator=\fP (\fBAsyncLinearMotionProfileController\fP &&other)=delete"
.br
.ti -1c
.RI "void \fBgeneratePath\fP (std::initializer_list< QLength > iwaypoints, const std::string &ipathId)"
.br
.ti -1c
.RI "void \fBgeneratePath\fP (std::initializer_list< QLength > iwaypoints, const std::string &ipathId, const \fBPathfinderLimits\fP &ilimits)"
.br
.ti -1c
.RI "bool \fBremovePath\fP (const std::string &ipathId)"
.br
.ti -1c
.RI "std::vector< std::string > \fBgetPaths\fP ()"
.br
.ti -1c
.RI "void \fBsetTarget\fP (std::string ipathId) override"
.br
.ti -1c
.RI "void \fBsetTarget\fP (std::string ipathId, bool ibackwards)"
.br
.ti -1c
.RI "void \fBcontrollerSet\fP (std::string ivalue) override"
.br
.ti -1c
.RI "std::string \fBgetTarget\fP () override"
.br
.ti -1c
.RI "virtual std::string \fBgetTarget\fP () const"
.br
.ti -1c
.RI "std::string \fBgetProcessValue\fP () const override"
.br
.ti -1c
.RI "void \fBwaitUntilSettled\fP () override"
.br
.ti -1c
.RI "void \fBmoveTo\fP (const QLength &iposition, const QLength &itarget, bool ibackwards=false)"
.br
.ti -1c
.RI "void \fBmoveTo\fP (const QLength &iposition, const QLength &itarget, const \fBPathfinderLimits\fP &ilimits, bool ibackwards=false)"
.br
.ti -1c
.RI "double \fBgetError\fP () const override"
.br
.ti -1c
.RI "bool \fBisSettled\fP () override"
.br
.ti -1c
.RI "void \fBreset\fP () override"
.br
.ti -1c
.RI "void \fBflipDisable\fP () override"
.br
.ti -1c
.RI "void \fBflipDisable\fP (bool iisDisabled) override"
.br
.ti -1c
.RI "bool \fBisDisabled\fP () const override"
.br
.ti -1c
.RI "void \fBtarePosition\fP () override"
.br
.ti -1c
.RI "void \fBsetMaxVelocity\fP (std::int32_t imaxVelocity) override"
.br
.ti -1c
.RI "void \fBstartThread\fP ()"
.br
.ti -1c
.RI "\fBCrossplatformThread\fP * \fBgetThread\fP () const"
.br
.ti -1c
.RI "void \fBforceRemovePath\fP (const std::string &ipathId)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBloop\fP ()"
.br
.ti -1c
.RI "virtual void \fBexecuteSinglePath\fP (const std::vector< \fBsquiggles::ProfilePoint\fP > &path, std::unique_ptr< \fBAbstractRate\fP > rate)"
.br
.ti -1c
.RI "QAngularSpeed \fBconvertLinearToRotational\fP (QSpeed linear) const"
.br
.ti -1c
.RI "std::string \fBgetPathErrorMessage\fP (const std::vector< \fBPathfinderPoint\fP > &points, const std::string &ipathId, int length)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBtrampoline\fP (void *context)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBLogger\fP > \fBlogger\fP"
.br
.ti -1c
.RI "std::map< std::string, std::vector< \fBsquiggles::ProfilePoint\fP > > \fBpaths\fP {}"
.br
.ti -1c
.RI "\fBPathfinderLimits\fP \fBlimits\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBControllerOutput\fP< double > > \fBoutput\fP"
.br
.ti -1c
.RI "QLength \fBdiameter\fP"
.br
.ti -1c
.RI "\fBAbstractMotor::GearsetRatioPair\fP \fBpair\fP"
.br
.ti -1c
.RI "double \fBcurrentProfilePosition\fP {0}"
.br
.ti -1c
.RI "\fBTimeUtil\fP \fBtimeUtil\fP"
.br
.ti -1c
.RI "\fBCrossplatformMutex\fP \fBcurrentPathMutex\fP"
.br
.ti -1c
.RI "std::string \fBcurrentPath\fP {''}"
.br
.ti -1c
.RI "std::atomic_bool \fBisRunning\fP {false}"
.br
.ti -1c
.RI "std::atomic_int \fBdirection\fP {1}"
.br
.ti -1c
.RI "std::atomic_bool \fBdisabled\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBdtorCalled\fP {false}"
.br
.ti -1c
.RI "\fBCrossplatformThread\fP * \fBtask\fP {nullptr}"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "okapi::AsyncLinearMotionProfileController::AsyncLinearMotionProfileController (const \fBTimeUtil\fP & itimeUtil, const \fBPathfinderLimits\fP & ilimits, const std::shared_ptr< \fBControllerOutput\fP< double > > & ioutput, const QLength & idiameter, const \fBAbstractMotor::GearsetRatioPair\fP & ipair, const std::shared_ptr< \fBLogger\fP > & ilogger = \fR\fBLogger::getDefaultLogger\fP()\fP)"
An Async \fBController\fP which generates and follows 1D motion profiles\&.

.PP
\fBParameters\fP
.RS 4
\fIitimeUtil\fP The \fBTimeUtil\fP\&. 
.br
\fIilimits\fP The default limits\&. 
.br
\fIioutput\fP The output to write velocity targets to\&. 
.br
\fIidiameter\fP The effective diameter for whatever the motor spins\&. 
.br
\fIipair\fP The gearset\&. 
.br
\fIilogger\fP The logger this instance will log to\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void okapi::AsyncLinearMotionProfileController::controllerSet (std::string ivalue)\fR [override]\fP, \fR [virtual]\fP"
Writes the value of the controller output\&. This method might be automatically called in another thread by the controller\&.

.PP
This just calls \fR\fBsetTarget()\fP\fP\&. 
.PP
Implements \fBokapi::ControllerOutput< std::string >\fP\&.
.SS "QAngularSpeed okapi::AsyncLinearMotionProfileController::convertLinearToRotational (QSpeed linear) const\fR [protected]\fP"
Converts linear "chassis" speed to rotational motor speed\&.

.PP
\fBParameters\fP
.RS 4
\fIlinear\fP "chassis" frame speed 
.RE
.PP
\fBReturns\fP
.RS 4
motor frame speed 
.RE
.PP

.SS "virtual void okapi::AsyncLinearMotionProfileController::executeSinglePath (const std::vector< \fBsquiggles::ProfilePoint\fP > & path, std::unique_ptr< \fBAbstractRate\fP > rate)\fR [protected]\fP, \fR [virtual]\fP"
Follow the supplied path\&. Must follow the disabled lifecycle\&. 
.SS "void okapi::AsyncLinearMotionProfileController::flipDisable ()\fR [override]\fP, \fR [virtual]\fP"
Changes whether the controller is off or on\&. Turning the controller on after it was off will NOT cause the controller to move to its last set target\&. 
.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "void okapi::AsyncLinearMotionProfileController::flipDisable (bool iisDisabled)\fR [override]\fP"
Sets whether the controller is off or on\&. Turning the controller on after it was off will NOT cause the controller to move to its last set target, unless it was reset in that time\&.

.PP
\fBParameters\fP
.RS 4
\fIiisDisabled\fP whether the controller is disabled 
.RE
.PP

.SS "void okapi::AsyncLinearMotionProfileController::forceRemovePath (const std::string & ipathId)"
Attempts to remove a path without stopping execution, then if that fails, disables the controller and removes the path\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP The path ID that will be removed 
.RE
.PP

.SS "void okapi::AsyncLinearMotionProfileController::generatePath (std::initializer_list< QLength > iwaypoints, const std::string & ipathId)"
Generates a path which intersects the given waypoints and saves it internally with a key of pathId\&. Call \fRexecutePath()\fP with the same \fRpathId\fP to run it\&.

.PP
If the waypoints form a path which is impossible to achieve, an instance of \fRstd::runtime_error\fP is thrown (and an error is logged) which describes the waypoints\&. If there are no waypoints, no path is generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiwaypoints\fP The waypoints to hit on the path\&. 
.br
\fIipathId\fP A unique identifier to save the path with\&. 
.RE
.PP

.SS "void okapi::AsyncLinearMotionProfileController::generatePath (std::initializer_list< QLength > iwaypoints, const std::string & ipathId, const \fBPathfinderLimits\fP & ilimits)"
Generates a path which intersects the given waypoints and saves it internally with a key of pathId\&. Call \fRexecutePath()\fP with the same pathId to run it\&.

.PP
If the waypoints form a path which is impossible to achieve, an instance of \fRstd::runtime_error\fP is thrown (and an error is logged) which describes the waypoints\&. If there are no waypoints, no path is generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiwaypoints\fP The waypoints to hit on the path\&. 
.br
\fIipathId\fP A unique identifier to save the path with\&. 
.br
\fIilimits\fP The limits to use for this path only\&. 
.RE
.PP

.SS "double okapi::AsyncLinearMotionProfileController::getError () const\fR [override]\fP, \fR [virtual]\fP"
Returns the last error of the controller\&. Does not update when disabled\&. Returns zero if there is no path currently being followed\&.

.PP
\fBReturns\fP
.RS 4
the last error 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "std::vector< std::string > okapi::AsyncLinearMotionProfileController::getPaths ()"
Gets the identifiers of all paths saved in this \fR\fBAsyncMotionProfileController\fP\fP\&.

.PP
\fBReturns\fP
.RS 4
The identifiers of all paths 
.RE
.PP

.SS "std::string okapi::AsyncLinearMotionProfileController::getProcessValue () const\fR [override]\fP, \fR [virtual]\fP"
This is overridden to return the current path\&.

.PP
\fBReturns\fP
.RS 4
The most recent value of the process variable\&. 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "virtual std::string okapi::AsyncLinearMotionProfileController::getTarget () const\fR [virtual]\fP"
Gets the last set target, or the default target if none was set\&.

.PP
\fBReturns\fP
.RS 4
the last target 
.RE
.PP

.SS "std::string okapi::AsyncLinearMotionProfileController::getTarget ()\fR [override]\fP, \fR [virtual]\fP"
Gets the last set target, or the default target if none was set\&.

.PP
\fBReturns\fP
.RS 4
the last target 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "\fBCrossplatformThread\fP * okapi::AsyncLinearMotionProfileController::getThread () const"
Returns the underlying thread handle\&.

.PP
\fBReturns\fP
.RS 4
The underlying thread handle\&. 
.RE
.PP

.SS "bool okapi::AsyncLinearMotionProfileController::isDisabled () const\fR [override]\fP, \fR [virtual]\fP"
Returns whether the controller is currently disabled\&.

.PP
\fBReturns\fP
.RS 4
whether the controller is currently disabled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "bool okapi::AsyncLinearMotionProfileController::isSettled ()\fR [override]\fP, \fR [virtual]\fP"
Returns whether the controller has settled at the target\&. Determining what settling means is implementation-dependent\&.

.PP
If the controller is disabled, this method must return \fRtrue\fP\&.

.PP
\fBReturns\fP
.RS 4
whether the controller is settled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "void okapi::AsyncLinearMotionProfileController::moveTo (const QLength & iposition, const QLength & itarget, bool ibackwards = \fRfalse\fP)"
Generates a new path from the position (typically the current position) to the target and blocks until the controller has settled\&. Does not save the path which was generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiposition\fP The starting position\&. 
.br
\fIitarget\fP The target position\&. 
.br
\fIibackwards\fP Whether to follow the profile backwards\&. 
.RE
.PP

.SS "void okapi::AsyncLinearMotionProfileController::moveTo (const QLength & iposition, const QLength & itarget, const \fBPathfinderLimits\fP & ilimits, bool ibackwards = \fRfalse\fP)"
Generates a new path from the position (typically the current position) to the target and blocks until the controller has settled\&. Does not save the path which was generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiposition\fP The starting position\&. 
.br
\fIitarget\fP The target position\&. 
.br
\fIilimits\fP The limits to use for this path only\&. 
.br
\fIibackwards\fP Whether to follow the profile backwards\&. 
.RE
.PP

.SS "bool okapi::AsyncLinearMotionProfileController::removePath (const std::string & ipathId)"
Removes a path and frees the memory it used\&. This function returns \fRtrue\fP if the path was either deleted or didn't exist in the first place\&. It returns \fRfalse\fP if the path could not be removed because it is running\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP A unique identifier for the path, previously passed to \fBgeneratePath()\fP 
.RE
.PP
\fBReturns\fP
.RS 4
\fRtrue\fP if the path no longer exists 
.RE
.PP

.SS "void okapi::AsyncLinearMotionProfileController::reset ()\fR [override]\fP, \fR [virtual]\fP"
Resets the controller's internal state so it is similar to when it was first initialized, while keeping any user-configured information\&. This implementation also stops movement\&. 
.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "void okapi::AsyncLinearMotionProfileController::setMaxVelocity (std::int32_t imaxVelocity)\fR [override]\fP, \fR [virtual]\fP"
This implementation does nothing because the maximum velocity is configured using \fBPathfinderLimits\fP elsewhere\&.

.PP
\fBParameters\fP
.RS 4
\fIimaxVelocity\fP Ignored\&. 
.RE
.PP

.PP
Implements \fBokapi::AsyncPositionController< std::string, double >\fP\&.
.SS "void okapi::AsyncLinearMotionProfileController::setTarget (std::string ipathId)\fR [override]\fP, \fR [virtual]\fP"
Executes a path with the given ID\&. If there is no path matching the ID, the method will return\&. Any targets set while a path is being followed will be ignored\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP A unique identifier for the path, previously passed to \fR\fBgeneratePath()\fP\fP\&. 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, double >\fP\&.
.SS "void okapi::AsyncLinearMotionProfileController::setTarget (std::string ipathId, bool ibackwards)"
Executes a path with the given ID\&. If there is no path matching the ID, the method will return\&. Any targets set while a path is being followed will be ignored\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP A unique identifier for the path, previously passed to \fR\fBgeneratePath()\fP\fP\&. 
.br
\fIibackwards\fP Whether to follow the profile backwards\&. 
.RE
.PP

.SS "void okapi::AsyncLinearMotionProfileController::startThread ()"
Starts the internal thread\&. This should not be called by normal users\&. This method is called by the AsyncControllerFactory when making a new instance of this class\&. 
.SS "void okapi::AsyncLinearMotionProfileController::tarePosition ()\fR [override]\fP, \fR [virtual]\fP"
This implementation does nothing because the API always requires the starting position to be specified\&. 
.PP
Implements \fBokapi::AsyncPositionController< std::string, double >\fP\&.
.SS "void okapi::AsyncLinearMotionProfileController::waitUntilSettled ()\fR [override]\fP, \fR [virtual]\fP"
Blocks the current task until the controller has settled\&. This controller is settled when it has finished following a path\&. If no path is being followed, it is settled\&. 
.PP
Implements \fBokapi::AsyncController< std::string, double >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
