.TH "ez::PID" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ez::PID
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBConstants\fP"
.br
.ti -1c
.RI "struct \fBexit_condition_\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBPID\fP ()"
.br
.ti -1c
.RI "\fBPID\fP (double p, double i=0, double d=0, double start_i=0, std::string name='')"
.br
.ti -1c
.RI "void \fBconstants_set\fP (double p, double i=0, double d=0, double p_start_i=0)"
.br
.ti -1c
.RI "void \fBexit_condition_set\fP (int p_small_exit_time, double p_small_error, int p_big_exit_time=0, double p_big_error=0, int p_velocity_exit_time=0, int p_mA_timeout=0)"
.br
.ti -1c
.RI "void \fBtarget_set\fP (double input)"
.br
.ti -1c
.RI "double \fBcompute\fP (double current)"
.br
.ti -1c
.RI "double \fBcompute_error\fP (double err, double current)"
.br
.ti -1c
.RI "double \fBtarget_get\fP ()"
.br
.ti -1c
.RI "\fBConstants\fP \fBconstants_get\fP ()"
.br
.ti -1c
.RI "bool \fBconstants_set_check\fP ()"
.br
.ti -1c
.RI "void \fBvariables_reset\fP ()"
.br
.ti -1c
.RI "void \fBvelocity_sensor_secondary_set\fP (double secondary_sensor)"
.br
.ti -1c
.RI "double \fBvelocity_sensor_secondary_get\fP ()"
.br
.ti -1c
.RI "void \fBvelocity_sensor_secondary_toggle_set\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBvelocity_sensor_secondary_toggle_get\fP ()"
.br
.ti -1c
.RI "void \fBvelocity_sensor_main_exit_set\fP (double zero)"
.br
.ti -1c
.RI "double \fBvelocity_sensor_main_exit_get\fP ()"
.br
.ti -1c
.RI "void \fBvelocity_sensor_secondary_exit_set\fP (double zero)"
.br
.ti -1c
.RI "double \fBvelocity_sensor_secondary_exit_get\fP ()"
.br
.ti -1c
.RI "ez::exit_output \fBexit_condition\fP (bool print=false)"
.br
.ti -1c
.RI "ez::exit_output \fBexit_condition\fP (\fBpros::Motor\fP sensor, bool print=false)"
.br
.ti -1c
.RI "ez::exit_output \fBexit_condition\fP (std::vector< \fBpros::Motor\fP > sensor, bool print=false)"
.br
.ti -1c
.RI "ez::exit_output \fBexit_condition\fP (\fBpros::MotorGroup\fP sensor, bool print=false)"
.br
.ti -1c
.RI "void \fBname_set\fP (std::string name)"
.br
.ti -1c
.RI "std::string \fBname_get\fP ()"
.br
.ti -1c
.RI "void \fBi_reset_toggle\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBi_reset_get\fP ()"
.br
.ti -1c
.RI "void \fBtimers_reset\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBConstants\fP \fBconstants\fP"
.br
.ti -1c
.RI "\fBexit_condition_\fP \fBexit\fP"
.br
.ti -1c
.RI "double \fBoutput\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBcur\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBerror\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBtarget\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBprev_error\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBprev_current\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBintegral\fP = 0\&.0"
.br
.ti -1c
.RI "double \fBderivative\fP = 0\&.0"
.br
.ti -1c
.RI "long \fBtime\fP = 0"
.br
.ti -1c
.RI "long \fBprev_time\fP = 0"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ez::PID::PID ()"
Default constructor\&. 
.SS "ez::PID::PID (double p, double i = \fR0\fP, double d = \fR0\fP, double start_i = \fR0\fP, std::string name = \fR''\fP)"
Constructor with constants\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP kP 
.br
\fIi\fP ki 
.br
\fId\fP kD 
.br
\fIp_start_i\fP error value that i starts within 
.br
\fIname\fP std::string of name that prints 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "double ez::PID::compute (double current)"
Computes \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIcurrent\fP current sensor value 
.RE
.PP

.SS "double ez::PID::compute_error (double err, double current)"
Computes \fBPID\fP, but you compute the error yourself\&.

.PP
Current is only used here for calculative derivative to solve derivative kick\&.

.PP
\fBParameters\fP
.RS 4
\fIerr\fP error for the \fBPID\fP, you need to calculate this yourself 
.br
\fIcurrent\fP current sensor value 
.RE
.PP

.SS "\fBConstants\fP ez::PID::constants_get ()"
Returns constants\&. 
.SS "void ez::PID::constants_set (double p, double i = \fR0\fP, double d = \fR0\fP, double p_start_i = \fR0\fP)"
Set constants for \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP kP 
.br
\fIi\fP ki 
.br
\fId\fP kD 
.br
\fIp_start_i\fP error value that i starts within 
.RE
.PP

.SS "bool ez::PID::constants_set_check ()"
Returns true if \fBPID\fP constants are set, returns false if they're all 0\&. 
.SS "ez::exit_output ez::PID::exit_condition (bool print = \fRfalse\fP)"
Iterative exit condition for \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIprint\fP = false if true, prints when complete 
.RE
.PP

.SS "ez::exit_output ez::PID::exit_condition (\fBpros::Motor\fP sensor, bool print = \fRfalse\fP)"
Iterative exit condition for \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIsensor\fP a pros motor on your mechanism 
.br
\fIprint\fP = false if true, prints when complete 
.RE
.PP

.SS "ez::exit_output ez::PID::exit_condition (\fBpros::MotorGroup\fP sensor, bool print = \fRfalse\fP)"
Iterative exit condition for \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIsensor\fP pros motor group on your mechanism 
.br
\fIprint\fP = false if true, prints when complete 
.RE
.PP

.SS "ez::exit_output ez::PID::exit_condition (std::vector< \fBpros::Motor\fP > sensor, bool print = \fRfalse\fP)"
Iterative exit condition for \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIsensor\fP pros motors on your mechanism 
.br
\fIprint\fP = false if true, prints when complete 
.RE
.PP

.SS "void ez::PID::exit_condition_set (int p_small_exit_time, double p_small_error, int p_big_exit_time = \fR0\fP, double p_big_error = \fR0\fP, int p_velocity_exit_time = \fR0\fP, int p_mA_timeout = \fR0\fP)"
Set's constants for exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP sets small_exit_time, timer for to exit within smalL_error 
.br
\fIp_small_error\fP sets smalL_error, timer will start when error is within this 
.br
\fIp_big_exit_time\fP sets big_exit_time, timer for to exit within big_error 
.br
\fIp_big_error\fP sets big_error, timer will start when error is within this 
.br
\fIp_velocity_exit_time\fP sets velocity_exit_time, timer will start when velocity is 0 
.RE
.PP

.SS "bool ez::PID::i_reset_get ()"
Returns if i will reset when sgn of error changes\&.

.PP
True resets, false doesn't\&. 
.SS "void ez::PID::i_reset_toggle (bool toggle)"
Enables / disables i resetting when sgn of error changes\&.

.PP
True resets, false doesn't\&.

.PP
\fBParameters\fP
.RS 4
\fItoggle\fP true resets, false doesn't 
.RE
.PP

.SS "std::string ez::PID::name_get ()"
Returns the name of the \fBPID\fP that prints during exit conditions\&. 
.SS "void ez::PID::name_set (std::string name)"
Sets the name of the \fBPID\fP that prints during exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIname\fP the name of the mechanism for printing 
.RE
.PP

.SS "double ez::PID::target_get ()"
Returns target value\&. 
.SS "void ez::PID::target_set (double input)"
Sets \fBPID\fP target\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP new target for \fBPID\fP 
.RE
.PP

.SS "void ez::PID::timers_reset ()"
Resets all timers for exit conditions\&. 
.SS "void ez::PID::variables_reset ()"
Resets all variables to 0\&. This does not reset constants\&. 
.SS "double ez::PID::velocity_sensor_main_exit_get ()"
Returns the threshold that the main sensor will return 0 velocity within\&. 
.SS "void ez::PID::velocity_sensor_main_exit_set (double zero)"
Sets the threshold that the main sensor will return 0 velocity within\&.

.PP
\fBParameters\fP
.RS 4
\fIzero\fP a small double 
.RE
.PP

.SS "double ez::PID::velocity_sensor_secondary_exit_get ()"
Returns the threshold that the secondary sensor will return 0 velocity within\&. 
.SS "void ez::PID::velocity_sensor_secondary_exit_set (double zero)"
Sets the threshold that the secondary sensor will return 0 velocity within\&.

.PP
\fBParameters\fP
.RS 4
\fIzero\fP a small double 
.RE
.PP

.SS "double ez::PID::velocity_sensor_secondary_get ()"
Returns the updated secondary sensor for velocity exiting\&. 
.SS "void ez::PID::velocity_sensor_secondary_set (double secondary_sensor)"
Updates a secondary sensor for velocity exiting\&. Ideal use is IMU during normal drive motions\&.

.PP
\fBParameters\fP
.RS 4
\fIsecondary_sensor\fP secondary sensor value 
.RE
.PP

.SS "bool ez::PID::velocity_sensor_secondary_toggle_get ()"
Returns the boolean for if the secondary sensor will be updated or not\&. True uses this sensor, false does not\&. 
.SS "void ez::PID::velocity_sensor_secondary_toggle_set (bool toggle)"
Boolean for if the secondary sensor will be updated or not\&. True uses this sensor, false does not\&.

.PP
\fBParameters\fP
.RS 4
\fItoggle\fP true uses this sensor, false does not 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBConstants\fP ez::PID::constants"
\fBConstants\fP\&. 
.SS "\fBexit_condition_\fP ez::PID::exit"
Exit\&. 
.SS "double ez::PID::output = 0\&.0"
\fBPID\fP variables\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
