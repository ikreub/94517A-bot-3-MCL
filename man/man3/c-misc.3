.TH "c-misc" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
c-misc \- Miscellaneous C API
.SH SYNOPSIS
.br
.PP
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBmisc\&.h\fP"
.br
.in -1c
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBdate_s_t\fP"
.br
.ti -1c
.RI "struct \fBtime_s_t\fP"
.br
.in -1c
.SS "V5 Competition"

.in +1c
.ti -1c
.RI "enum \fBcompetition_status\fP { \fBCOMPETITION_DISABLED\fP = 1 << 0, \fBCOMPETITION_CONNECTED\fP = 1 << 2, \fBCOMPETITION_AUTONOMOUS\fP = 1 << 1, \fBCOMPETITION_SYSTEM\fP = 1 << 3 }"
.br
.ti -1c
.RI "const char * \fBbaked_date\fP"
.br
.ti -1c
.RI "const char * \fBbaked_time\fP"
.br
.ti -1c
.RI "uint8_t \fBcompetition_get_status\fP (void)"
.br
.ti -1c
.RI "uint8_t \fBcompetition_is_disabled\fP (void)"
.br
.ti -1c
.RI "uint8_t \fBcompetition_is_connected\fP (void)"
.br
.ti -1c
.RI "uint8_t \fBcompetition_is_autonomous\fP (void)"
.br
.ti -1c
.RI "uint8_t \fBcompetition_is_field\fP (void)"
.br
.ti -1c
.RI "int32_t \fBcontroller_is_connected\fP (controller_id_e_t id)"
.br
.ti -1c
.RI "int32_t \fBcontroller_get_analog\fP (controller_id_e_t id, controller_analog_e_t channel)"
.br
.ti -1c
.RI "int32_t \fBcontroller_get_battery_capacity\fP (controller_id_e_t id)"
.br
.ti -1c
.RI "int32_t \fBcontroller_get_battery_level\fP (controller_id_e_t id)"
.br
.ti -1c
.RI "int32_t \fBcontroller_get_digital\fP (controller_id_e_t id, controller_digital_e_t button)"
.br
.ti -1c
.RI "int32_t \fBcontroller_get_digital_new_press\fP (controller_id_e_t id, controller_digital_e_t button)"
.br
.ti -1c
.RI "int32_t \fBcontroller_print\fP (controller_id_e_t id, uint8_t line, uint8_t col, const char *fmt,\&.\&.\&.)"
.br
.ti -1c
.RI "int32_t \fBcontroller_set_text\fP (controller_id_e_t id, uint8_t line, uint8_t col, const char *str)"
.br
.ti -1c
.RI "int32_t \fBcontroller_clear_line\fP (controller_id_e_t id, uint8_t line)"
.br
.ti -1c
.RI "int32_t \fBcontroller_clear\fP (controller_id_e_t id)"
.br
.ti -1c
.RI "int32_t \fBcontroller_rumble\fP (controller_id_e_t id, const char *rumble_pattern)"
.br
.ti -1c
.RI "int32_t \fBbattery_get_voltage\fP (void)"
.br
.ti -1c
.RI "int32_t \fBbattery_get_current\fP (void)"
.br
.ti -1c
.RI "double \fBbattery_get_temperature\fP (void)"
.br
.ti -1c
.RI "double \fBbattery_get_capacity\fP (void)"
.br
.ti -1c
.RI "int32_t \fBusd_is_installed\fP (void)"
.br
.ti -1c
.RI "int32_t \fBusd_list_files\fP (const char *path, char *buffer, int32_t len)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBNote\fP
.RS 4
Additional example code for this module can be found in its \fBTutorial\&.\fP
.RE
.PP

.SH "Function Documentation"
.PP 
.SS "double battery_get_capacity (void )"
Gets the current capacity of the battery, as reported by VEXos\&.

.PP
This function uses the following values of errno when an error state is reached: EACCES - Another resource is currently trying to access the battery port\&.

.PP
\fBReturns\fP
.RS 4
The current capacity of the battery
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t battery_get_current (void )"
Gets the current current of the battery, as reported by VEXos\&.

.PP
This function uses the following values of errno when an error state is reached: EACCES - Another resource is currently trying to access the battery port\&.

.PP
\fBReturns\fP
.RS 4
The current current of the battery
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "double battery_get_temperature (void )"
Gets the current temperature of the battery, as reported by VEXos\&.

.PP
This function uses the following values of errno when an error state is reached: EACCES - Another resource is currently trying to access the battery port\&.

.PP
\fBReturns\fP
.RS 4
The current temperature of the battery
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t battery_get_voltage (void )"
Gets the current voltage of the battery, as reported by VEXos\&.

.PP
This function uses the following values of errno when an error state is reached: EACCES - Another resource is currently trying to access the battery port\&.

.PP
\fBReturns\fP
.RS 4
The current voltage of the battery
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint8_t competition_get_status (void )"
Get the current status of the competition control\&.

.PP
\fBReturns\fP
.RS 4
The competition control status as a mask of bits with COMPETITION_{ENABLED,AUTONOMOUS,CONNECTED}\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint8_t competition_is_autonomous (void )"

.PP
\fBReturns\fP
.RS 4
True if the V5 Brain is in autonomous mode, false otherwise\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint8_t competition_is_connected (void )"

.PP
\fBReturns\fP
.RS 4
True if the V5 Brain is connected to competition control, false otherwise\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint8_t competition_is_disabled (void )"

.PP
\fBReturns\fP
.RS 4
True if the V5 Brain is disabled, false otherwise\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint8_t competition_is_field (void )"

.PP
\fBReturns\fP
.RS 4
True if the V5 Brain is connected to VEXnet Field Controller, false otherwise\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_clear (controller_id_e_t id)"
Clears all of the lines on the controller screen\&.

.PP
\fBNote\fP
.RS 4
Controller text setting is a slow process, so updates faster than 10ms when on a wired connection or 50ms over Vexnet will not be applied to the controller\&.
.RE
.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&. EAGAIN - Could not send the text to the controller\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER
.RE
.PP
\fBReturns\fP
.RS 4
1 if the operation was successful or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_clear_line (controller_id_e_t id, uint8_t line)"
Clears an individual line of the controller screen\&.

.PP
\fBNote\fP
.RS 4
Controller text setting is currently in beta, so continuous, fast updates will not work well\&.
.RE
.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIline\fP The line number to clear [0-2]
.RE
.PP
\fBReturns\fP
.RS 4
1 if the operation was successful or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_get_analog (controller_id_e_t id, controller_analog_e_t channel)"
Gets the value of an analog channel (joystick) on a controller\&.

.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIchannel\fP The analog channel to get\&. Must be one of ANALOG_LEFT_X, ANALOG_LEFT_Y, ANALOG_RIGHT_X, ANALOG_RIGHT_Y
.RE
.PP
\fBReturns\fP
.RS 4
The current reading of the analog channel: [-127, 127]\&. If the controller was not connected, then 0 is returned
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_get_battery_capacity (controller_id_e_t id)"
Gets the battery capacity of the given controller\&.

.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER
.RE
.PP
\fBReturns\fP
.RS 4
The controller's battery capacity
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_get_battery_level (controller_id_e_t id)"
Gets the battery level of the given controller\&.

.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER
.RE
.PP
\fBReturns\fP
.RS 4
The controller's battery level
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_get_digital (controller_id_e_t id, controller_digital_e_t button)"
Checks if a digital channel (button) on the controller is currently pressed\&.

.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIbutton\fP The button to read\&. Must be one of DIGITAL_{RIGHT,DOWN,LEFT,UP,A,B,Y,X,R1,R2,L1,L2}
.RE
.PP
\fBReturns\fP
.RS 4
1 if the button on the controller is pressed\&. If the controller was not connected, then 0 is returned
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_get_digital_new_press (controller_id_e_t id, controller_digital_e_t button)"
Returns a rising-edge case for a controller button press\&.

.PP
This function is not thread-safe\&. Multiple tasks polling a single button may return different results under the same circumstances, so only one task should call this function for any given button\&. E\&.g\&., Task A calls this function for buttons 1 and 2\&. Task B may call this function for button 3, but should not for buttons 1 or 2\&. A typical use-case for this function is to call inside opcontrol to detect new button presses, and not in any other tasks\&.

.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIbutton\fP The button to read\&. Must be one of DIGITAL_{RIGHT,DOWN,LEFT,UP,A,B,Y,X,R1,R2,L1,L2}
.RE
.PP
\fBReturns\fP
.RS 4
1 if the button on the controller is pressed and had not been pressed the last time this function was called, 0 otherwise\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_is_connected (controller_id_e_t id)"

.PP
\fBReturns\fP
.RS 4
True if the V5 Brain is connected to VEXnet Competition Switch, false otherwise\&.
.RE
.PP
\fBExample\fP 
.PP
.nf


#ifdef __cplusplus
extern "C" {
namespace pros {
#endif

typedef enum {
    E_CONTROLLER_MASTER = 0,
    E_CONTROLLER_PARTNER
} controller_id_e_t;

typedef enum {
    E_CONTROLLER_ANALOG_LEFT_X = 0,
    E_CONTROLLER_ANALOG_LEFT_Y,
    E_CONTROLLER_ANALOG_RIGHT_X,
    E_CONTROLLER_ANALOG_RIGHT_Y
} controller_analog_e_t;

typedef enum {
    E_CONTROLLER_DIGITAL_L1 = 6,
    E_CONTROLLER_DIGITAL_L2,
    E_CONTROLLER_DIGITAL_R1,
    E_CONTROLLER_DIGITAL_R2,
    E_CONTROLLER_DIGITAL_UP,
    E_CONTROLLER_DIGITAL_DOWN,
    E_CONTROLLER_DIGITAL_LEFT,
    E_CONTROLLER_DIGITAL_RIGHT,
    E_CONTROLLER_DIGITAL_X,
    E_CONTROLLER_DIGITAL_B,
    E_CONTROLLER_DIGITAL_Y,
    E_CONTROLLER_DIGITAL_A
} controller_digital_e_t;

#ifdef PROS_USE_SIMPLE_NAMES
#ifdef __cplusplus
#define CONTROLLER_MASTER pros::E_CONTROLLER_MASTER
#define CONTROLLER_PARTNER pros::E_CONTROLLER_PARTNER
#define ANALOG_LEFT_X pros::E_CONTROLLER_ANALOG_LEFT_X
#define ANALOG_LEFT_Y pros::E_CONTROLLER_ANALOG_LEFT_Y
#define ANALOG_RIGHT_X pros::E_CONTROLLER_ANALOG_RIGHT_X
#define ANALOG_RIGHT_Y pros::E_CONTROLLER_ANALOG_RIGHT_Y
#define DIGITAL_L1 pros::E_CONTROLLER_DIGITAL_L1
#define DIGITAL_L2 pros::E_CONTROLLER_DIGITAL_L2
#define DIGITAL_R1 pros::E_CONTROLLER_DIGITAL_R1
#define DIGITAL_R2 pros::E_CONTROLLER_DIGITAL_R2
#define DIGITAL_UP pros::E_CONTROLLER_DIGITAL_UP
#define DIGITAL_DOWN pros::E_CONTROLLER_DIGITAL_DOWN
#define DIGITAL_LEFT pros::E_CONTROLLER_DIGITAL_LEFT
#define DIGITAL_RIGHT pros::E_CONTROLLER_DIGITAL_RIGHT
#define DIGITAL_X pros::E_CONTROLLER_DIGITAL_X
#define DIGITAL_B pros::E_CONTROLLER_DIGITAL_B
#define DIGITAL_Y pros::E_CONTROLLER_DIGITAL_Y
#define DIGITAL_A pros::E_CONTROLLER_DIGITAL_A
#else
#define CONTROLLER_MASTER E_CONTROLLER_MASTER
#define CONTROLLER_PARTNER E_CONTROLLER_PARTNER
#define ANALOG_LEFT_X E_CONTROLLER_ANALOG_LEFT_X
#define ANALOG_LEFT_Y E_CONTROLLER_ANALOG_LEFT_Y
#define ANALOG_RIGHT_X E_CONTROLLER_ANALOG_RIGHT_X
#define ANALOG_RIGHT_Y E_CONTROLLER_ANALOG_RIGHT_Y
#define DIGITAL_L1 E_CONTROLLER_DIGITAL_L1
#define DIGITAL_L2 E_CONTROLLER_DIGITAL_L2
#define DIGITAL_R1 E_CONTROLLER_DIGITAL_R1
#define DIGITAL_R2 E_CONTROLLER_DIGITAL_R2
#define DIGITAL_UP E_CONTROLLER_DIGITAL_UP
#define DIGITAL_DOWN E_CONTROLLER_DIGITAL_DOWN
#define DIGITAL_LEFT E_CONTROLLER_DIGITAL_LEFT
#define DIGITAL_RIGHT E_CONTROLLER_DIGITAL_RIGHT
#define DIGITAL_X E_CONTROLLER_DIGITAL_X
#define DIGITAL_B E_CONTROLLER_DIGITAL_B
#define DIGITAL_Y E_CONTROLLER_DIGITAL_Y
#define DIGITAL_A E_CONTROLLER_DIGITAL_A
#endif
#endif

#define CONTROLLER_PORT_MUTEX_TAKE(id, port) \\
    switch (id) {                              \\
        case E_CONTROLLER_MASTER:                \\
            port = V5_PORT_CONTROLLER_1;           \\
            break;                                 \\
        case E_CONTROLLER_PARTNER:               \\
            port = V5_PORT_CONTROLLER_2;           \\
            break;                                 \\
        default:                                 \\
            errno = EINVAL;                        \\
            return PROS_ERR;                       \\
    }                                          \\
    if (!internal_port_mutex_take(port)) {     \\
        errno = EACCES;                          \\
        return PROS_ERR;                         \\
    }

#ifdef __cplusplus
namespace c {
#endif

.fi
.PP
 
.SS "int32_t controller_print (controller_id_e_t id, uint8_t line, uint8_t col, const char * fmt,  \&.\&.\&.)"
Sets text to the controller LCD screen\&.

.PP
\fBNote\fP
.RS 4
Controller text setting is a slow process, so updates faster than 10ms when on a wired connection or 50ms over Vexnet will not be applied to the controller\&.
.RE
.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&. EAGAIN - Could not send the text to the controller\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIline\fP The line number at which the text will be displayed [0-2] 
.br
\fIcol\fP The column number at which the text will be displayed [0-14] 
.br
\fIfmt\fP The format string to print to the controller 
.br
\fI\&.\&.\&.\fP The argument list for the format string
.RE
.PP
\fBReturns\fP
.RS 4
1 if the operation was successful or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_rumble (controller_id_e_t id, const char * rumble_pattern)"
Rumble the controller\&.

.PP
\fBNote\fP
.RS 4
Controller rumble activation is a slow process, so updates faster than 10ms when on a wired connection or 50ms over Vexnet will not be applied to the controller\&.
.RE
.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIrumble_pattern\fP A string consisting of the characters '\&.', '-', and ' ', where dots are short rumbles, dashes are long rumbles, and spaces are pauses\&. Maximum supported length is 8 characters\&.
.RE
.PP
\fBReturns\fP
.RS 4
1 if the operation was successful or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t controller_set_text (controller_id_e_t id, uint8_t line, uint8_t col, const char * str)"
Sets text to the controller LCD screen\&.

.PP
\fBNote\fP
.RS 4
Controller text setting is a slow process, so updates faster than 10ms when on a wired connection or 50ms over Vexnet will not be applied to the controller\&.
.RE
.PP
This function uses the following values of errno when an error state is reached: EINVAL - A value other than E_CONTROLLER_MASTER or E_CONTROLLER_PARTNER is given\&. EACCES - Another resource is currently trying to access the controller port\&. EAGAIN - Could not send the text to the controller\&.

.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID of the controller (e\&.g\&. the master or partner controller)\&. Must be one of CONTROLLER_MASTER or CONTROLLER_PARTNER 
.br
\fIline\fP The line number at which the text will be displayed [0-2] 
.br
\fIcol\fP The column number at which the text will be displayed [0-14] 
.br
\fIstr\fP The pre-formatted string to print to the controller
.RE
.PP
\fBReturns\fP
.RS 4
1 if the operation was successful or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t usd_is_installed (void )"
Checks if the SD card is installed\&.

.PP
\fBReturns\fP
.RS 4
1 if the SD card is installed, 0 otherwise
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t usd_list_files (const char * path, char * buffer, int32_t len)"
Lists the files in a directory specified by the path Puts the list of file names (NOT DIRECTORIES) into the buffer seperated by newlines

.PP
This function uses the following values of errno when an error state is reached:

.PP
EIO - Hard error occured in the low level disk I/O layer EINVAL - file or directory is invalid, or length is invalid EBUSY - THe physical drinve cannot work ENOENT - cannot find the path or file EINVAL - the path name format is invalid EACCES - Access denied or directory full EEXIST - Access denied EROFS - SD card is write protected ENXIO - drive number is invalid or not a FAT32 drive ENOBUFS - drive has no work area ENFILE - too many open files

.PP
\fBNote\fP
.RS 4
use a path of "\\" to list the files in the main directory NOT "/usd/" DO NOT PREPEND YOUR PATHS WITH "/usd/"\\return 1 on success or PROS_ERR on failure setting errno\\b Example@code void opcontrol() {    char* test = (char*) malloc(128); pros::c::usd_list_files("/", test, 128); pros::delay(200); printf("s
.br
", test); //Prints the file names in the root directory seperated by newlines pros::delay(100); pros::c::usd_list_files("/test", test, 128); pros::delay(200); printf("s
.br
", test); //Prints the names of files in the folder named test seperated by newlines pros::delay(100); }  
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "const char* baked_date\fR [extern]\fP"
Date and Time 
.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
