.TH "include/liblvgl/misc/lv_fs.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/misc/lv_fs.h
.SH SYNOPSIS
.br
.PP
\fR#include 'liblvgl/lv_conf_internal\&.h'\fP
.br
\fR#include <stdint\&.h>\fP
.br
\fR#include <stdbool\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fB_lv_fs_drv_t\fP"
.br
.ti -1c
.RI "struct \fBlv_fs_file_cache_t\fP"
.br
.ti -1c
.RI "struct \fBlv_fs_file_t\fP"
.br
.ti -1c
.RI "struct \fBlv_fs_dir_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLV_FS_MAX_FN_LENGTH\fP   64"
.br
.ti -1c
.RI "#define \fBLV_FS_MAX_PATH_LENGTH\fP   256"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBlv_fs_res_t\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBlv_fs_mode_t\fP"
.br
.ti -1c
.RI "typedef struct \fB_lv_fs_drv_t\fP \fBlv_fs_drv_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBLV_FS_RES_OK\fP = 0, \fBLV_FS_RES_HW_ERR\fP, \fBLV_FS_RES_FS_ERR\fP, \fBLV_FS_RES_NOT_EX\fP, \fBLV_FS_RES_FULL\fP, \fBLV_FS_RES_LOCKED\fP, \fBLV_FS_RES_DENIED\fP, \fBLV_FS_RES_BUSY\fP, \fBLV_FS_RES_TOUT\fP, \fBLV_FS_RES_NOT_IMP\fP, \fBLV_FS_RES_OUT_OF_MEM\fP, \fBLV_FS_RES_INV_PARAM\fP, \fBLV_FS_RES_UNKNOWN\fP }"
.br
.ti -1c
.RI "enum { \fBLV_FS_MODE_WR\fP = 0x01, \fBLV_FS_MODE_RD\fP = 0x02 }"
.br
.ti -1c
.RI "enum \fBlv_fs_whence_t\fP { \fBLV_FS_SEEK_SET\fP = 0x00, \fBLV_FS_SEEK_CUR\fP = 0x01, \fBLV_FS_SEEK_END\fP = 0x02 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_lv_fs_init\fP (void)"
.br
.ti -1c
.RI "void \fBlv_fs_drv_init\fP (lv_fs_drv_t *drv)"
.br
.ti -1c
.RI "void \fBlv_fs_drv_register\fP (lv_fs_drv_t *drv)"
.br
.ti -1c
.RI "lv_fs_drv_t * \fBlv_fs_get_drv\fP (char letter)"
.br
.ti -1c
.RI "bool \fBlv_fs_is_ready\fP (char letter)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_open\fP (\fBlv_fs_file_t\fP *file_p, const char *path, lv_fs_mode_t mode)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_close\fP (\fBlv_fs_file_t\fP *file_p)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_read\fP (\fBlv_fs_file_t\fP *file_p, void *buf, uint32_t btr, uint32_t *br)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_write\fP (\fBlv_fs_file_t\fP *file_p, const void *buf, uint32_t btw, uint32_t *bw)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_seek\fP (\fBlv_fs_file_t\fP *file_p, uint32_t pos, \fBlv_fs_whence_t\fP whence)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_tell\fP (\fBlv_fs_file_t\fP *file_p, uint32_t *pos)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_dir_open\fP (\fBlv_fs_dir_t\fP *rddir_p, const char *path)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_dir_read\fP (\fBlv_fs_dir_t\fP *rddir_p, char *fn)"
.br
.ti -1c
.RI "lv_fs_res_t \fBlv_fs_dir_close\fP (\fBlv_fs_dir_t\fP *rddir_p)"
.br
.ti -1c
.RI "char * \fBlv_fs_get_letters\fP (char *buf)"
.br
.ti -1c
.RI "const char * \fBlv_fs_get_ext\fP (const char *fn)"
.br
.ti -1c
.RI "char * \fBlv_fs_up\fP (char *path)"
.br
.ti -1c
.RI "const char * \fBlv_fs_get_last\fP (const char *path)"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
Errors in the file system module\&. 
.SS "anonymous enum"
File open mode\&. 
.SS "enum \fBlv_fs_whence_t\fP"
Seek modes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILV_FS_SEEK_SET \fP
Set the position from absolutely (from the start of file) 
.TP
\f(BILV_FS_SEEK_CUR \fP
Set the position from the current position 
.TP
\f(BILV_FS_SEEK_END \fP
Set the position from the end of the file 
.SH "Function Documentation"
.PP 
.SS "void _lv_fs_init (void )"
Initialize the File system interface 
.SS "lv_fs_res_t lv_fs_close (\fBlv_fs_file_t\fP * file_p)"
Close an already opened file 
.PP
\fBParameters\fP
.RS 4
\fIfile_p\fP pointer to a \fBlv_fs_file_t\fP variable 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "lv_fs_res_t lv_fs_dir_close (\fBlv_fs_dir_t\fP * rddir_p)"
Close the directory reading 
.PP
\fBParameters\fP
.RS 4
\fIrddir_p\fP pointer to an initialized 'fs_dir_t' variable 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "lv_fs_res_t lv_fs_dir_open (\fBlv_fs_dir_t\fP * rddir_p, const char * path)"
Initialize a 'fs_dir_t' variable for directory reading 
.PP
\fBParameters\fP
.RS 4
\fIrddir_p\fP pointer to a '\fBlv_fs_dir_t\fP' variable 
.br
\fIpath\fP path to a directory 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "lv_fs_res_t lv_fs_dir_read (\fBlv_fs_dir_t\fP * rddir_p, char * fn)"
Read the next filename form a directory\&. The name of the directories will begin with '/' 
.PP
\fBParameters\fP
.RS 4
\fIrddir_p\fP pointer to an initialized 'fs_dir_t' variable 
.br
\fIfn\fP pointer to a buffer to store the filename 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "void lv_fs_drv_init (lv_fs_drv_t * drv)"
Initialize a file system driver with default values\&. It is used to surly have known values in the fields ant not memory junk\&. After it you can set the fields\&. 
.PP
\fBParameters\fP
.RS 4
\fIdrv\fP pointer to driver variable to initialize 
.RE
.PP

.SS "void lv_fs_drv_register (lv_fs_drv_t * drv)"
Add a new drive 
.PP
\fBParameters\fP
.RS 4
\fIdrv\fP pointer to an lv_fs_drv_t structure which is inited with the corresponding function pointers\&. Only pointer is saved, so the driver should be static or dynamically allocated\&. 
.RE
.PP

.SS "lv_fs_drv_t * lv_fs_get_drv (char letter)"
Give a pointer to a driver from its letter 
.PP
\fBParameters\fP
.RS 4
\fIletter\fP the driver letter 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to a driver or NULL if not found 
.RE
.PP

.SS "const char * lv_fs_get_ext (const char * fn)"
Return with the extension of the filename 
.PP
\fBParameters\fP
.RS 4
\fIfn\fP string with a filename 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the beginning extension or empty string if no extension 
.RE
.PP

.SS "const char * lv_fs_get_last (const char * path)"
Get the last element of a path (e\&.g\&. U:/folder/file -> file) 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP pointer to a file name 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the beginning of the last element in the path 
.RE
.PP

.SS "char * lv_fs_get_letters (char * buf)"
Fill a buffer with the letters of existing drivers 
.PP
\fBParameters\fP
.RS 4
\fIbuf\fP buffer to store the letters ('\\0' added after the last letter) 
.RE
.PP
\fBReturns\fP
.RS 4
the buffer 
.RE
.PP

.SS "bool lv_fs_is_ready (char letter)"
Test if a drive is ready or not\&. If the \fRready\fP function was not initialized \fRtrue\fP will be returned\&. 
.PP
\fBParameters\fP
.RS 4
\fIletter\fP letter of the drive 
.RE
.PP
\fBReturns\fP
.RS 4
true: drive is ready; false: drive is not ready 
.RE
.PP

.SS "lv_fs_res_t lv_fs_open (\fBlv_fs_file_t\fP * file_p, const char * path, lv_fs_mode_t mode)"
Open a file 
.PP
\fBParameters\fP
.RS 4
\fIfile_p\fP pointer to a \fBlv_fs_file_t\fP variable 
.br
\fIpath\fP path to the file beginning with the driver letter (e\&.g\&. S:/folder/file\&.txt) 
.br
\fImode\fP read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "lv_fs_res_t lv_fs_read (\fBlv_fs_file_t\fP * file_p, void * buf, uint32_t btr, uint32_t * br)"
Read from a file 
.PP
\fBParameters\fP
.RS 4
\fIfile_p\fP pointer to a \fBlv_fs_file_t\fP variable 
.br
\fIbuf\fP pointer to a buffer where the read bytes are stored 
.br
\fIbtr\fP Bytes To Read 
.br
\fIbr\fP the number of real read bytes (Bytes Read)\&. NULL if unused\&. 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "lv_fs_res_t lv_fs_seek (\fBlv_fs_file_t\fP * file_p, uint32_t pos, \fBlv_fs_whence_t\fP whence)"
Set the position of the 'cursor' (read write pointer) in a file 
.PP
\fBParameters\fP
.RS 4
\fIfile_p\fP pointer to a \fBlv_fs_file_t\fP variable 
.br
\fIpos\fP the new position expressed in bytes index (0: start of file) 
.br
\fIwhence\fP tells from where set the position\&. See @lv_fs_whence_t 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SS "lv_fs_res_t lv_fs_tell (\fBlv_fs_file_t\fP * file_p, uint32_t * pos)"
Give the position of the read write pointer 
.PP
\fBParameters\fP
.RS 4
\fIfile_p\fP pointer to a \fBlv_fs_file_t\fP variable 
.br
\fIpos_p\fP pointer to store the position of the read write pointer 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from 'fs_res_t' 
.RE
.PP

.SS "char * lv_fs_up (char * path)"
Step up one level 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP pointer to a file name 
.RE
.PP
\fBReturns\fP
.RS 4
the truncated file name 
.RE
.PP

.SS "lv_fs_res_t lv_fs_write (\fBlv_fs_file_t\fP * file_p, const void * buf, uint32_t btw, uint32_t * bw)"
Write into a file 
.PP
\fBParameters\fP
.RS 4
\fIfile_p\fP pointer to a \fBlv_fs_file_t\fP variable 
.br
\fIbuf\fP pointer to a buffer with the bytes to write 
.br
\fIbtw\fP Bytes To Write 
.br
\fIbw\fP the number of real written bytes (Bytes Written)\&. NULL if unused\&. 
.RE
.PP
\fBReturns\fP
.RS 4
LV_FS_RES_OK or any error from lv_fs_res_t enum 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
