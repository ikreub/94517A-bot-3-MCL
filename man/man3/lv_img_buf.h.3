.TH "include/liblvgl/draw/lv_img_buf.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/draw/lv_img_buf.h
.SH SYNOPSIS
.br
.PP
\fR#include <stdbool\&.h>\fP
.br
\fR#include 'liblvgl/misc/lv_color\&.h'\fP
.br
\fR#include 'liblvgl/misc/lv_area\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBlv_img_header_t\fP"
.br
.ti -1c
.RI "struct \fBlv_img_dsc_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_TRUE_COLOR\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_TRUE_COLOR_CHROMA_KEYED\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_TRUE_COLOR_ALPHA\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_ALPHA_1BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_ALPHA_2BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_ALPHA_4BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_ALPHA_8BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_INDEXED_1BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_INDEXED_2BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_INDEXED_4BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fBLV_IMG_BUF_SIZE_INDEXED_8BIT\fP(w,  h)"
.br
.ti -1c
.RI "#define \fB_LV_ZOOM_INV_UPSCALE\fP   5"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBlv_img_cf_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBLV_IMG_CF_UNKNOWN\fP = 0, \fBLV_IMG_CF_RAW\fP, \fBLV_IMG_CF_RAW_ALPHA\fP, \fBLV_IMG_CF_RAW_CHROMA_KEYED\fP, \fBLV_IMG_CF_TRUE_COLOR\fP, \fBLV_IMG_CF_TRUE_COLOR_ALPHA\fP, \fBLV_IMG_CF_TRUE_COLOR_CHROMA_KEYED\fP, \fBLV_IMG_CF_INDEXED_1BIT\fP, \fBLV_IMG_CF_INDEXED_2BIT\fP, \fBLV_IMG_CF_INDEXED_4BIT\fP, \fBLV_IMG_CF_INDEXED_8BIT\fP, \fBLV_IMG_CF_ALPHA_1BIT\fP, \fBLV_IMG_CF_ALPHA_2BIT\fP, \fBLV_IMG_CF_ALPHA_4BIT\fP, \fBLV_IMG_CF_ALPHA_8BIT\fP, \fBLV_IMG_CF_RGB888\fP, \fBLV_IMG_CF_RGBA8888\fP, \fBLV_IMG_CF_RGBX8888\fP, \fBLV_IMG_CF_RGB565\fP, \fBLV_IMG_CF_RGBA5658\fP, \fBLV_IMG_CF_RGB565A8\fP, \fBLV_IMG_CF_RESERVED_15\fP, \fBLV_IMG_CF_RESERVED_16\fP, \fBLV_IMG_CF_RESERVED_17\fP, \fBLV_IMG_CF_RESERVED_18\fP, \fBLV_IMG_CF_RESERVED_19\fP, \fBLV_IMG_CF_RESERVED_20\fP, \fBLV_IMG_CF_RESERVED_21\fP, \fBLV_IMG_CF_RESERVED_22\fP, \fBLV_IMG_CF_RESERVED_23\fP, \fBLV_IMG_CF_USER_ENCODED_0\fP, \fBLV_IMG_CF_USER_ENCODED_1\fP, \fBLV_IMG_CF_USER_ENCODED_2\fP, \fBLV_IMG_CF_USER_ENCODED_3\fP, \fBLV_IMG_CF_USER_ENCODED_4\fP, \fBLV_IMG_CF_USER_ENCODED_5\fP, \fBLV_IMG_CF_USER_ENCODED_6\fP, \fBLV_IMG_CF_USER_ENCODED_7\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBlv_img_dsc_t\fP * \fBlv_img_buf_alloc\fP (lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)"
.br
.ti -1c
.RI "lv_color_t \fBlv_img_buf_get_px_color\fP (\fBlv_img_dsc_t\fP *dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)"
.br
.ti -1c
.RI "lv_opa_t \fBlv_img_buf_get_px_alpha\fP (\fBlv_img_dsc_t\fP *dsc, lv_coord_t x, lv_coord_t y)"
.br
.ti -1c
.RI "void \fBlv_img_buf_set_px_color\fP (\fBlv_img_dsc_t\fP *dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)"
.br
.ti -1c
.RI "void \fBlv_img_buf_set_px_alpha\fP (\fBlv_img_dsc_t\fP *dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)"
.br
.ti -1c
.RI "void \fBlv_img_buf_set_palette\fP (\fBlv_img_dsc_t\fP *dsc, uint8_t id, lv_color_t c)"
.br
.ti -1c
.RI "void \fBlv_img_buf_free\fP (\fBlv_img_dsc_t\fP *dsc)"
.br
.ti -1c
.RI "uint32_t \fBlv_img_buf_get_img_size\fP (lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)"
.br
.ti -1c
.RI "void \fB_lv_img_buf_get_transformed_area\fP (\fBlv_area_t\fP *res, lv_coord_t w, lv_coord_t h, int16_t angle, uint16_t zoom, const \fBlv_point_t\fP *pivot)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define LV_IMG_BUF_SIZE_ALPHA_1BIT( w,  h)"
\fBValue:\fP
.nf
((((w / 8) + 1) * h))
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_ALPHA_2BIT( w,  h)"
\fBValue:\fP
.nf
((((w / 4) + 1) * h))
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_ALPHA_4BIT( w,  h)"
\fBValue:\fP
.nf
((((w / 2) + 1) * h))
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_ALPHA_8BIT( w,  h)"
\fBValue:\fP
.nf
((w * h))
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_INDEXED_1BIT( w,  h)"
\fBValue:\fP
.nf
(LV_IMG_BUF_SIZE_ALPHA_1BIT(w, h) + 4 * 2)
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_INDEXED_2BIT( w,  h)"
\fBValue:\fP
.nf
(LV_IMG_BUF_SIZE_ALPHA_2BIT(w, h) + 4 * 4)
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_INDEXED_4BIT( w,  h)"
\fBValue:\fP
.nf
(LV_IMG_BUF_SIZE_ALPHA_4BIT(w, h) + 4 * 16)
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_INDEXED_8BIT( w,  h)"
\fBValue:\fP
.nf
(LV_IMG_BUF_SIZE_ALPHA_8BIT(w, h) + 4 * 256)
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_TRUE_COLOR( w,  h)"
\fBValue:\fP
.nf
((LV_COLOR_SIZE / 8) * w * h)
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_TRUE_COLOR_ALPHA( w,  h)"
\fBValue:\fP
.nf
(LV_IMG_PX_SIZE_ALPHA_BYTE * w * h)
.PP
.fi

.SS "#define LV_IMG_BUF_SIZE_TRUE_COLOR_CHROMA_KEYED( w,  h)"
\fBValue:\fP
.nf
((LV_COLOR_SIZE / 8) * w * h)
.PP
.fi

.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"

.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILV_IMG_CF_RAW \fP
Contains the file as it is\&. Needs custom decoder function 
.TP
\f(BILV_IMG_CF_RAW_ALPHA \fP
Contains the file as it is\&. The image has alpha\&. Needs custom decoder function 
.TP
\f(BILV_IMG_CF_RAW_CHROMA_KEYED \fP
Contains the file as it is\&. The image is chroma keyed\&. Needs custom decoder function 
.TP
\f(BILV_IMG_CF_TRUE_COLOR \fP
Color format and depth should match with LV_COLOR settings 
.TP
\f(BILV_IMG_CF_TRUE_COLOR_ALPHA \fP
Same as \fR\fBLV_IMG_CF_TRUE_COLOR\fP\fP but every pixel has an alpha byte 
.TP
\f(BILV_IMG_CF_TRUE_COLOR_CHROMA_KEYED \fP
Same as \fR\fBLV_IMG_CF_TRUE_COLOR\fP\fP but LV_COLOR_TRANSP pixels will be transparent 
.TP
\f(BILV_IMG_CF_INDEXED_1BIT \fP
Can have 2 different colors in a palette (can't be chroma keyed) 
.TP
\f(BILV_IMG_CF_INDEXED_2BIT \fP
Can have 4 different colors in a palette (can't be chroma keyed) 
.TP
\f(BILV_IMG_CF_INDEXED_4BIT \fP
Can have 16 different colors in a palette (can't be chroma keyed) 
.TP
\f(BILV_IMG_CF_INDEXED_8BIT \fP
Can have 256 different colors in a palette (can't be chroma keyed) 
.TP
\f(BILV_IMG_CF_ALPHA_1BIT \fP
Can have one color and it can be drawn or not 
.TP
\f(BILV_IMG_CF_ALPHA_2BIT \fP
Can have one color but 4 different alpha value 
.TP
\f(BILV_IMG_CF_ALPHA_4BIT \fP
Can have one color but 16 different alpha value 
.TP
\f(BILV_IMG_CF_ALPHA_8BIT \fP
Can have one color but 256 different alpha value 
.TP
\f(BILV_IMG_CF_RESERVED_15 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_16 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_17 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_18 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_19 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_20 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_21 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_22 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_RESERVED_23 \fP
Reserved for further use\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_0 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_1 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_2 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_3 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_4 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_5 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_6 \fP
User holder encoding format\&. 
.TP
\f(BILV_IMG_CF_USER_ENCODED_7 \fP
User holder encoding format\&. 
.SH "Function Documentation"
.PP 
.SS "void _lv_img_buf_get_transformed_area (\fBlv_area_t\fP * res, lv_coord_t w, lv_coord_t h, int16_t angle, uint16_t zoom, const \fBlv_point_t\fP * pivot)"
Get the area of a rectangle if its rotated and scaled 
.PP
\fBParameters\fP
.RS 4
\fIres\fP store the coordinates here 
.br
\fIw\fP width of the rectangle to transform 
.br
\fIh\fP height of the rectangle to transform 
.br
\fIangle\fP angle of rotation 
.br
\fIzoom\fP zoom, (256 no zoom) 
.br
\fIpivot\fP x,y pivot coordinates of rotation 
.RE
.PP

.SS "\fBlv_img_dsc_t\fP * lv_img_buf_alloc (lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)"
Allocate an image buffer in RAM 
.PP
\fBParameters\fP
.RS 4
\fIw\fP width of image 
.br
\fIh\fP height of image 
.br
\fIcf\fP a color format (\fRLV_IMG_CF_\&.\&.\&.\fP) 
.RE
.PP
\fBReturns\fP
.RS 4
an allocated image, or NULL on failure 
.RE
.PP

.SS "void lv_img_buf_free (\fBlv_img_dsc_t\fP * dsc)"
Free an allocated image buffer 
.PP
\fBParameters\fP
.RS 4
\fIdsc\fP image buffer to free 
.RE
.PP

.SS "uint32_t lv_img_buf_get_img_size (lv_coord_t w, lv_coord_t h, lv_img_cf_t cf)"
Get the memory consumption of a raw bitmap, given color format and dimensions\&. 
.PP
\fBParameters\fP
.RS 4
\fIw\fP width 
.br
\fIh\fP height 
.br
\fIcf\fP color format 
.RE
.PP
\fBReturns\fP
.RS 4
size in bytes 
.RE
.PP

.SS "lv_opa_t lv_img_buf_get_px_alpha (\fBlv_img_dsc_t\fP * dsc, lv_coord_t x, lv_coord_t y)"
Get the alpha value of an image's pixel 
.PP
\fBParameters\fP
.RS 4
\fIdsc\fP pointer to an image descriptor 
.br
\fIx\fP x coordinate of the point to set 
.br
\fIy\fP x coordinate of the point to set 
.br
\fIsafe\fP true: check out of bounds 
.RE
.PP
\fBReturns\fP
.RS 4
alpha value of the point 
.RE
.PP

.SS "lv_color_t lv_img_buf_get_px_color (\fBlv_img_dsc_t\fP * dsc, lv_coord_t x, lv_coord_t y, lv_color_t color)"
Get the color of an image's pixel 
.PP
\fBParameters\fP
.RS 4
\fIdsc\fP an image descriptor 
.br
\fIx\fP x coordinate of the point to get 
.br
\fIy\fP x coordinate of the point to get 
.br
\fIcolor\fP the color of the image\&. In case of \fRLV_IMG_CF_ALPHA_1/2/4/8\fP this color is used\&. Not used in other cases\&. 
.br
\fIsafe\fP true: check out of bounds 
.RE
.PP
\fBReturns\fP
.RS 4
color of the point 
.RE
.PP

.SS "void lv_img_buf_set_palette (\fBlv_img_dsc_t\fP * dsc, uint8_t id, lv_color_t c)"
Set the palette color of an indexed image\&. Valid only for \fRLV_IMG_CF_INDEXED1/2/4/8\fP 
.PP
\fBParameters\fP
.RS 4
\fIdsc\fP pointer to an image descriptor 
.br
\fIid\fP the palette color to set:
.IP "\(bu" 2
for \fRLV_IMG_CF_INDEXED1\fP: 0\&.\&.1
.IP "\(bu" 2
for \fRLV_IMG_CF_INDEXED2\fP: 0\&.\&.3
.IP "\(bu" 2
for \fRLV_IMG_CF_INDEXED4\fP: 0\&.\&.15
.IP "\(bu" 2
for \fRLV_IMG_CF_INDEXED8\fP: 0\&.\&.255 
.PP
.br
\fIc\fP the color to set 
.RE
.PP

.SS "void lv_img_buf_set_px_alpha (\fBlv_img_dsc_t\fP * dsc, lv_coord_t x, lv_coord_t y, lv_opa_t opa)"
Set the alpha value of a pixel of an image\&. The color won't be affected 
.PP
\fBParameters\fP
.RS 4
\fIdsc\fP pointer to an image descriptor 
.br
\fIx\fP x coordinate of the point to set 
.br
\fIy\fP x coordinate of the point to set 
.br
\fIopa\fP the desired opacity 
.br
\fIsafe\fP true: check out of bounds 
.RE
.PP

.SS "void lv_img_buf_set_px_color (\fBlv_img_dsc_t\fP * dsc, lv_coord_t x, lv_coord_t y, lv_color_t c)"
Set the color of a pixel of an image\&. The alpha channel won't be affected\&. 
.PP
\fBParameters\fP
.RS 4
\fIdsc\fP pointer to an image descriptor 
.br
\fIx\fP x coordinate of the point to set 
.br
\fIy\fP x coordinate of the point to set 
.br
\fIc\fP color of the point 
.br
\fIsafe\fP true: check out of bounds 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
