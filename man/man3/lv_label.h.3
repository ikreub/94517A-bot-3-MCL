.TH "include/liblvgl/widgets/lv_label.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/widgets/lv_label.h
.SH SYNOPSIS
.br
.PP
\fR#include '\&.\&./lv_conf_internal\&.h'\fP
.br
\fR#include <stdarg\&.h>\fP
.br
\fR#include 'liblvgl/core/lv_obj\&.h'\fP
.br
\fR#include 'liblvgl/font/lv_font\&.h'\fP
.br
\fR#include 'liblvgl/font/lv_symbol_def\&.h'\fP
.br
\fR#include 'liblvgl/misc/lv_txt\&.h'\fP
.br
\fR#include 'liblvgl/draw/lv_draw\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBlv_label_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLV_LABEL_WAIT_CHAR_COUNT\fP   3"
.br
.ti -1c
.RI "#define \fBLV_LABEL_DOT_NUM\fP   3"
.br
.ti -1c
.RI "#define \fBLV_LABEL_POS_LAST\fP   0xFFFF"
.br
.ti -1c
.RI "#define \fBLV_LABEL_TEXT_SELECTION_OFF\fP   LV_DRAW_LABEL_NO_TXT_SEL"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBlv_label_long_mode_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBLV_LABEL_LONG_WRAP\fP, \fBLV_LABEL_LONG_DOT\fP, \fBLV_LABEL_LONG_SCROLL\fP, \fBLV_LABEL_LONG_SCROLL_CIRCULAR\fP, \fBLV_LABEL_LONG_CLIP\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBLV_EXPORT_CONST_INT\fP (LV_LABEL_DOT_NUM)"
.br
.ti -1c
.RI "\fBLV_EXPORT_CONST_INT\fP (LV_LABEL_POS_LAST)"
.br
.ti -1c
.RI "\fBLV_EXPORT_CONST_INT\fP (LV_LABEL_TEXT_SELECTION_OFF)"
.br
.ti -1c
.RI "lv_obj_t * \fBlv_label_create\fP (lv_obj_t *parent)"
.br
.ti -1c
.RI "void \fBlv_label_set_text\fP (lv_obj_t *obj, const char *text)"
.br
.ti -1c
.RI "void \fBlv_label_set_text_fmt\fP (lv_obj_t *obj, const char *fmt,\&.\&.\&.) LV_FORMAT_ATTRIBUTE(2"
.br
.ti -1c
.RI "void void \fBlv_label_set_text_static\fP (lv_obj_t *obj, const char *text)"
.br
.ti -1c
.RI "void \fBlv_label_set_long_mode\fP (lv_obj_t *obj, lv_label_long_mode_t long_mode)"
.br
.ti -1c
.RI "void \fBlv_label_set_recolor\fP (lv_obj_t *obj, bool en)"
.br
.ti -1c
.RI "void \fBlv_label_set_text_sel_start\fP (lv_obj_t *obj, uint32_t index)"
.br
.ti -1c
.RI "void \fBlv_label_set_text_sel_end\fP (lv_obj_t *obj, uint32_t index)"
.br
.ti -1c
.RI "char * \fBlv_label_get_text\fP (const lv_obj_t *obj)"
.br
.ti -1c
.RI "lv_label_long_mode_t \fBlv_label_get_long_mode\fP (const lv_obj_t *obj)"
.br
.ti -1c
.RI "bool \fBlv_label_get_recolor\fP (const lv_obj_t *obj)"
.br
.ti -1c
.RI "void \fBlv_label_get_letter_pos\fP (const lv_obj_t *obj, uint32_t char_id, \fBlv_point_t\fP *pos)"
.br
.ti -1c
.RI "uint32_t \fBlv_label_get_letter_on\fP (const lv_obj_t *obj, \fBlv_point_t\fP *pos_in)"
.br
.ti -1c
.RI "bool \fBlv_label_is_char_under_pos\fP (const lv_obj_t *obj, \fBlv_point_t\fP *pos)"
.br
.ti -1c
.RI "uint32_t \fBlv_label_get_text_selection_start\fP (const lv_obj_t *obj)"
.br
.RI "Get the selection start index\&. "
.ti -1c
.RI "uint32_t \fBlv_label_get_text_selection_end\fP (const lv_obj_t *obj)"
.br
.RI "Get the selection end index\&. "
.ti -1c
.RI "void \fBlv_label_ins_text\fP (lv_obj_t *obj, uint32_t pos, const char *txt)"
.br
.ti -1c
.RI "void \fBlv_label_cut_text\fP (lv_obj_t *obj, uint32_t pos, uint32_t cnt)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const \fBlv_obj_class_t\fP \fBlv_label_class\fP"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
Long mode behaviors\&. Used in 'lv_label_ext_t' 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILV_LABEL_LONG_WRAP \fP
Keep the object width, wrap the too long lines and expand the object height 
.TP
\f(BILV_LABEL_LONG_DOT \fP
Keep the size and write dots at the end if the text is too long 
.TP
\f(BILV_LABEL_LONG_SCROLL \fP
Keep the size and roll the text back and forth 
.TP
\f(BILV_LABEL_LONG_SCROLL_CIRCULAR \fP
Keep the size and roll the text circularly 
.TP
\f(BILV_LABEL_LONG_CLIP \fP
Keep the size and clip the text out of it 
.SH "Function Documentation"
.PP 
.SS "lv_obj_t * lv_label_create (lv_obj_t * parent)"
Create a label object 
.PP
\fBParameters\fP
.RS 4
\fIparent\fP pointer to an object, it will be the parent of the new label\&. 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the created button 
.RE
.PP

.SS "void lv_label_cut_text (lv_obj_t * obj, uint32_t pos, uint32_t cnt)"
Delete characters from a label\&. The label text can not be static\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIpos\fP character index from where to cut\&. Expressed in character index and not byte index\&. 0: start in from of the first character 
.br
\fIcnt\fP number of characters to cut 
.RE
.PP

.SS "uint32_t lv_label_get_letter_on (const lv_obj_t * obj, \fBlv_point_t\fP * pos_in)"
Get the index of letter on a relative point of a label\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to label object 
.br
\fIpos\fP pointer to point with coordinates on a the label 
.RE
.PP
\fBReturns\fP
.RS 4
The index of the letter on the 'pos_p' point (E\&.g\&. on 0;0 is the 0\&. letter if aligned to the left) Expressed in character index and not byte index (different in UTF-8) 
.RE
.PP

.SS "void lv_label_get_letter_pos (const lv_obj_t * obj, uint32_t char_id, \fBlv_point_t\fP * pos)"
Get the relative x and y coordinates of a letter 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIindex\fP index of the character [0 \&.\&.\&. text length - 1]\&. Expressed in character index, not byte index (different in UTF-8) 
.br
\fIpos\fP store the result here (E\&.g\&. index = 0 gives 0;0 coordinates if the text if aligned to the left) 
.RE
.PP

.SS "lv_label_long_mode_t lv_label_get_long_mode (const lv_obj_t * obj)"
Get the long mode of a label 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.RE
.PP
\fBReturns\fP
.RS 4
the current long mode 
.RE
.PP

.SS "bool lv_label_get_recolor (const lv_obj_t * obj)"
Get the recoloring attribute 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.RE
.PP
\fBReturns\fP
.RS 4
true: recoloring is enabled, false: disable 
.RE
.PP

.SS "char * lv_label_get_text (const lv_obj_t * obj)"
Get the text of a label 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.RE
.PP
\fBReturns\fP
.RS 4
the text of the label 
.RE
.PP

.SS "uint32_t lv_label_get_text_selection_end (const lv_obj_t * obj)"

.PP
Get the selection end index\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
selection end index\&. \fRLV_LABEL_TXT_SEL_OFF\fP if nothing is selected\&. 
.RE
.PP

.SS "uint32_t lv_label_get_text_selection_start (const lv_obj_t * obj)"

.PP
Get the selection start index\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object\&. 
.RE
.PP
\fBReturns\fP
.RS 4
selection start index\&. \fRLV_LABEL_TEXT_SELECTION_OFF\fP if nothing is selected\&. 
.RE
.PP

.SS "void lv_label_ins_text (lv_obj_t * obj, uint32_t pos, const char * txt)"
Insert a text to a label\&. The label text can not be static\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIpos\fP character index to insert\&. Expressed in character index and not byte index\&. 0: before first char\&. LV_LABEL_POS_LAST: after last char\&. 
.br
\fItxt\fP pointer to the text to insert 
.RE
.PP

.SS "bool lv_label_is_char_under_pos (const lv_obj_t * obj, \fBlv_point_t\fP * pos)"
Check if a character is drawn under a point\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIpos\fP Point to check for character under 
.RE
.PP
\fBReturns\fP
.RS 4
whether a character is drawn under the point 
.RE
.PP

.SS "void lv_label_set_long_mode (lv_obj_t * obj, lv_label_long_mode_t long_mode)"
Set the behavior of the label with longer text then the object size 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIlong_mode\fP the new mode from 'lv_label_long_mode' enum\&. In LV_LONG_WRAP/DOT/SCROLL/SCROLL_CIRC the size of the label should be set AFTER this function 
.RE
.PP

.SS "void lv_label_set_text (lv_obj_t * obj, const char * text)"
Set a new text for a label\&. Memory will be allocated to store the text by the label\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fItext\fP '\\0' terminated character string\&. NULL to refresh with the current text\&. 
.RE
.PP

.SS "void lv_label_set_text_sel_end (lv_obj_t * obj, uint32_t index)"
Set where text selection should end 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIindex\fP character index where selection should end\&. \fRLV_LABEL_TEXT_SELECTION_OFF\fP for no selection 
.RE
.PP

.SS "void lv_label_set_text_sel_start (lv_obj_t * obj, uint32_t index)"
Set where text selection should start 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fIindex\fP character index from where selection should start\&. \fRLV_LABEL_TEXT_SELECTION_OFF\fP for no selection 
.RE
.PP

.SS "void void lv_label_set_text_static (lv_obj_t * obj, const char * text)"
Set a static text\&. It will not be saved by the label so the 'text' variable has to be 'alive' while the label exists\&. 
.PP
\fBParameters\fP
.RS 4
\fIobj\fP pointer to a label object 
.br
\fItext\fP pointer to a text\&. NULL to refresh with the current text\&. 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
