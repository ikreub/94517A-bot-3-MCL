.TH "c-rtos" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
c-rtos \- RTOS Facilities C API
.SH SYNOPSIS
.br
.PP
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBrtos\&.h\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCURRENT_TASK\fP   ((\fBtask_t\fP)NULL)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "uint32_t \fBmillis\fP (void)"
.br
.ti -1c
.RI "uint64_t \fBmicros\fP (void)"
.br
.ti -1c
.RI "\fBtask_t\fP \fBtask_create\fP (\fBtask_fn_t\fP function, void *const parameters, uint32_t prio, const uint16_t stack_depth, const char *const name)"
.br
.ti -1c
.RI "void \fBtask_delete\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "void \fBtask_delay\fP (const uint32_t milliseconds)"
.br
.ti -1c
.RI "void \fBdelay\fP (const uint32_t milliseconds)"
.br
.ti -1c
.RI "void \fBtask_delay_until\fP (uint32_t *const prev_time, const uint32_t delta)"
.br
.ti -1c
.RI "uint32_t \fBtask_get_priority\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "void \fBtask_set_priority\fP (\fBtask_t\fP task, uint32_t prio)"
.br
.ti -1c
.RI "\fBtask_state_e_t\fP \fBtask_get_state\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "void \fBtask_suspend\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "void \fBtask_resume\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "uint32_t \fBtask_get_count\fP (void)"
.br
.ti -1c
.RI "char * \fBtask_get_name\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "\fBtask_t\fP \fBtask_get_by_name\fP (const char *name)"
.br
.ti -1c
.RI "\fBtask_t\fP \fBtask_get_current\fP ()"
.br
.ti -1c
.RI "uint32_t \fBtask_notify\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "void \fBtask_join\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "uint32_t \fBtask_notify_ext\fP (\fBtask_t\fP task, uint32_t value, \fBnotify_action_e_t\fP action, uint32_t *prev_value)"
.br
.ti -1c
.RI "uint32_t \fBtask_notify_take\fP (bool clear_on_exit, uint32_t timeout)"
.br
.ti -1c
.RI "bool \fBtask_notify_clear\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "\fBmutex_t\fP \fBmutex_create\fP (void)"
.br
.ti -1c
.RI "bool \fBmutex_take\fP (\fBmutex_t\fP mutex, uint32_t timeout)"
.br
.ti -1c
.RI "bool \fBmutex_give\fP (\fBmutex_t\fP mutex)"
.br
.ti -1c
.RI "void \fBmutex_delete\fP (\fBmutex_t\fP mutex)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBtask_state_e_t\fP { \fBE_TASK_STATE_RUNNING\fP = 0, \fBE_TASK_STATE_READY\fP, \fBE_TASK_STATE_BLOCKED\fP, \fBE_TASK_STATE_SUSPENDED\fP, \fBE_TASK_STATE_DELETED\fP, \fBE_TASK_STATE_INVALID\fP }"
.br
.ti -1c
.RI "enum \fBnotify_action_e_t\fP { \fBE_NOTIFY_ACTION_NONE\fP, \fBE_NOTIFY_ACTION_BITS\fP, \fBE_NOTIFY_ACTION_INCR\fP, \fBE_NOTIFY_ACTION_OWRITE\fP, \fBE_NOTIFY_ACTION_NO_OWRITE\fP }"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void * \fBtask_t\fP"
.br
.ti -1c
.RI "typedef void(* \fBtask_fn_t\fP) (void *)"
.br
.ti -1c
.RI "typedef void * \fBmutex_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBTASK_PRIORITY_MAX\fP   16"
.br
.ti -1c
.RI "#define \fBTASK_PRIORITY_MIN\fP   1"
.br
.ti -1c
.RI "#define \fBTASK_PRIORITY_DEFAULT\fP   8"
.br
.ti -1c
.RI "#define \fBTASK_STACK_DEPTH_DEFAULT\fP   0x2000"
.br
.ti -1c
.RI "#define \fBTASK_STACK_DEPTH_MIN\fP   0x200"
.br
.ti -1c
.RI "#define \fBTASK_NAME_MAX_LEN\fP   32"
.br
.ti -1c
.RI "#define \fBTIMEOUT_MAX\fP   ((uint32_t)0xffffffffUL)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBNote\fP
.RS 4
Additional example code for this module can be found in its \fBTutorial\&.\fP
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define CURRENT_TASK   ((\fBtask_t\fP)NULL)"
The task handle of the currently running task\&. 
.SS "#define TASK_NAME_MAX_LEN   32"
The maximum number of characters allowed in a task's name\&. 
.SS "#define TASK_PRIORITY_DEFAULT   8"
The default task priority, which should be used for most tasks unless you have a specific need for a higher or lower priority task\&.

.PP
The default tasks, such as \fBautonomous()\fP, are run with this priority 
.SS "#define TASK_PRIORITY_MAX   16"
The highest priority that can be assigned to a task\&.

.PP
A task with this priority will always run if it is available to\&. Beware of deadlocks when using this priority\&. 
.SS "#define TASK_PRIORITY_MIN   1"
The lowest priority that can be assigned to a task\&.

.PP
This can cause severe performance problems and is generally not recommended that users use this priority\&. 
.SS "#define TASK_STACK_DEPTH_DEFAULT   0x2000"
The recommended stack size for a new task\&.

.PP
This stack size is used for the default tasks such as \fBautonomous()\fP\&. This size is 8,192 words, or 32,768 bytes\&. This should be enough for the majority of tasks 
.SS "#define TASK_STACK_DEPTH_MIN   0x200"
The minimal stack size for a task\&.

.PP
This equates to 512 words, or 2,048 bytes\&. 
.SS "#define TIMEOUT_MAX   ((uint32_t)0xffffffffUL)"
The maximum timeout value that can be given to, for instance, a mutex grab\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef void* \fBmutex_t\fP"
A \fBmutex\&.\fP

.PP
A mutex is a synchronization object that can be used to protect a shared resource from being accessed by multiple tasks at the same time\&. A mutex can be claimed by a task, which will prevent other tasks from claiming it until that task releases it\&. 
.SS "typedef void(* task_fn_t) (void *)"
A pointer to a task's function\&.

.PP
Such a function is called when a task starts, and exiting said function will terminate the task\&. 
.SS "typedef void* \fBtask_t\fP"
An opaque type that pontis to a task handle\&. This is used for referencing a task\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBnotify_action_e_t\fP"
brief The action to take when a task is notified\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIE_NOTIFY_ACTION_NONE \fP
The task’s notification value will not be touched\&. 
.TP
\f(BIE_NOTIFY_ACTION_BITS \fP
The task’s notification value will be bitwise ORed with the new value\&. 
.TP
\f(BIE_NOTIFY_ACTION_INCR \fP
The task’s notification value will be incremented by one, effectively using it as a notification counter\&. 
.TP
\f(BIE_NOTIFY_ACTION_OWRITE \fP
The task’s notification value will be unconditionally set to the new value\&. 
.TP
\f(BIE_NOTIFY_ACTION_NO_OWRITE \fP
The task’s notification value will be set to the new value if the task does not already have a pending notification\&. 
.SS "enum \fBtask_state_e_t\fP"
The state of a task\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BIE_TASK_STATE_RUNNING \fP
The task is actively executing\&. 
.TP
\f(BIE_TASK_STATE_READY \fP
The task exists and is available to run, but is not currently running\&. 
.TP
\f(BIE_TASK_STATE_BLOCKED \fP
The task is delayed or blocked by a mutex, semaphore, or I/O operation\&. 
.TP
\f(BIE_TASK_STATE_SUSPENDED \fP
The task is supended using task_suspend\&. 
.TP
\f(BIE_TASK_STATE_DELETED \fP
The task has been deleted using task_delete\&. 
.TP
\f(BIE_TASK_STATE_INVALID \fP
The task handle does not point to a current or past task\&. 
.SH "Function Documentation"
.PP 
.SS "void delay (const uint32_t milliseconds)"
Delays the current task for a given number of milliseconds\&.

.PP
This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested\&. To delay cyclically, use \fBtask_delay_until()\fP\&.

.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP The number of milliseconds to wait (1000 milliseconds per second)
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.PP
\fBExamples\fP
.in +1c
\fBC:/Users/Leon/OneDrive/robotics/94517A\-bot\-3\-MCL/include/liblvgl/misc/lv_style\&.h\fP\&.
.SS "uint64_t micros (void )"
Gets the number of microseconds since PROS initialized,

.PP
\fBReturns\fP
.RS 4
The number of microseconds since PROS initialized
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t millis (void )"
Gets the number of milliseconds since PROS initialized\&.

.PP
\fBReturns\fP
.RS 4
The number of milliseconds since PROS initialized
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBmutex_t\fP mutex_create (void )"
Creates a mutex\&.

.PP
See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes for details\&.

.PP
\fBReturns\fP
.RS 4
A handle to a newly created mutex\&. If an error occurred, NULL will be returned and errno can be checked for hints as to why mutex_create failed\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void mutex_delete (\fBmutex_t\fP mutex)"
Deletes a mutex

.PP
\fBParameters\fP
.RS 4
\fImutex\fP Mutex to unlock\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "bool mutex_give (\fBmutex_t\fP mutex)"
Unlocks a mutex\&.

.PP
See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes for details\&.

.PP
\fBParameters\fP
.RS 4
\fImutex\fP Mutex to unlock\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if the mutex was successfully returned, false otherwise\&. If false is returned, then errno is set with a hint about why the mutex couldn't be returned\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "bool mutex_take (\fBmutex_t\fP mutex, uint32_t timeout)"
Takes and locks a mutex, waiting for up to a certain number of milliseconds before timing out\&.

.PP
See https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes for details\&.

.PP
\fBParameters\fP
.RS 4
\fImutex\fP Mutex to attempt to lock\&. 
.br
\fItimeout\fP Time to wait before the mutex becomes available\&. A timeout of 0 can be used to poll the mutex\&. TIMEOUT_MAX can be used to block indefinitely\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if the mutex was successfully taken, false otherwise\&. If false is returned, then errno is set with a hint about why the the mutex couldn't be taken\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBtask_t\fP task_create (\fBtask_fn_t\fP function, void *const parameters, uint32_t prio, const uint16_t stack_depth, const char *const name)"
Creates a new task and add it to the list of tasks that are ready to run\&.

.PP
This function uses the following values of errno when an error state is reached: ENOMEM - The stack cannot be used as the TCB was not created\&.

.PP
\fBParameters\fP
.RS 4
\fIfunction\fP Pointer to the task entry function 
.br
\fIparameters\fP Pointer to memory that will be used as a parameter for the task being created\&. This memory should not typically come from stack, but rather from dynamically (i\&.e\&., malloc'd) or statically allocated memory\&. 
.br
\fIprio\fP The priority at which the task should run\&. TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used\&. 
.br
\fIstack_depth\fP The number of words (i\&.e\&. 4 * stack_depth) available on the task's stack\&. TASK_STACK_DEPTH_DEFAULT is typically sufficienct\&. 
.br
\fIname\fP A descriptive name for the task\&. This is mainly used to facilitate debugging\&. The name may be up to 32 characters long\&.
.RE
.PP
\fBReturns\fP
.RS 4
A handle by which the newly created task can be referenced\&. If an error occurred, NULL will be returned and errno can be checked for hints as to why task_create failed\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_delay (const uint32_t milliseconds)"
Delays the current task for a given number of milliseconds\&.

.PP
This is not the best method to have a task execute code at predefined intervals, as the delay time is measured from when the delay is requested\&. To delay cyclically, use \fBtask_delay_until()\fP\&.

.PP
\fBParameters\fP
.RS 4
\fImilliseconds\fP The number of milliseconds to wait (1000 milliseconds per second)
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_delay_until (uint32_t *const prev_time, const uint32_t delta)"
Delays the current task until a specified time\&. This function can be used by periodic tasks to ensure a constant execution frequency\&.

.PP
The task will be woken up at the time *prev_time + delta, and *prev_time will be updated to reflect the time at which the task will unblock\&.

.PP
\fBParameters\fP
.RS 4
\fIprev_time\fP A pointer to the location storing the setpoint time\&. This should typically be initialized to the return value of \fBmillis()\fP\&. 
.br
\fIdelta\fP The number of milliseconds to wait (1000 milliseconds per second)
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_delete (\fBtask_t\fP task)"
Removes a task from the RTOS real time kernel's management\&. The task being deleted will be removed from all ready, blocked, suspended and event lists\&.

.PP
Memory dynamically allocated by the task is not automatically freed, and should be freed before the task is deleted\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The handle of the task to be deleted\&. Passing NULL will cause the calling task to be deleted\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBtask_t\fP task_get_by_name (const char * name)"
Gets a task handle from the specified name

.PP
The operation takes a relatively long time and should be used sparingly\&.

.PP
\fBParameters\fP
.RS 4
\fIname\fP The name to query
.RE
.PP
\fBReturns\fP
.RS 4
A task handle with a matching name, or NULL if none were found\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t task_get_count (void )"
Gets the number of tasks the kernel is currently managing, including all ready, blocked, or suspended tasks\&. A task that has been deleted, but not yet reaped by the idle task will also be included in the count\&. Tasks recently created may take one context switch to be counted\&.

.PP
\fBReturns\fP
.RS 4
The number of tasks that are currently being managed by the kernel\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBtask_t\fP task_get_current ()"
Get the currently running task handle\&. This could be useful if a task wants to tell another task about itself\&.

.PP
\fBReturns\fP
.RS 4
The currently running task handle\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "char * task_get_name (\fBtask_t\fP task)"
Gets the name of the specified task\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to check
.RE
.PP
\fBReturns\fP
.RS 4
A pointer to the name of the task
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t task_get_priority (\fBtask_t\fP task)"
Gets the priority of the specified task\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to check
.RE
.PP
\fBReturns\fP
.RS 4
The priority of the task
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBtask_state_e_t\fP task_get_state (\fBtask_t\fP task)"
Gets the state of the specified task\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to check
.RE
.PP
\fBReturns\fP
.RS 4
The state of the task
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_join (\fBtask_t\fP task)"
Utilizes task notifications to wait until specified task is complete and deleted, then continues to execute the program\&. Analogous to std::thread::join in C++\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The handle of the task to wait on\&.
.RE
.PP
\fBReturns\fP
.RS 4
void
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t task_notify (\fBtask_t\fP task)"
Sends a simple notification to task and increments the notification counter\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to notify
.RE
.PP
\fBReturns\fP
.RS 4
Always returns true\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "bool task_notify_clear (\fBtask_t\fP task)"
Clears the notification for a task\&.

.PP
See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for details\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to clear
.RE
.PP
\fBReturns\fP
.RS 4
False if there was not a notification waiting, true if there was
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t task_notify_ext (\fBtask_t\fP task, uint32_t value, \fBnotify_action_e_t\fP action, uint32_t * prev_value)"
Sends a notification to a task, optionally performing some action\&. Will also retrieve the value of the notification in the target task before modifying the notification value\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to notify 
.br
\fIvalue\fP The value used in performing the action 
.br
\fIaction\fP An action to optionally perform on the receiving task's notification value 
.br
\fIprev_value\fP A pointer to store the previous value of the target task's notification, may be NULL
.RE
.PP
\fBReturns\fP
.RS 4
Dependent on the notification action\&. For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without needing to overwrite, 1 otherwise\&. For all other NOTIFY_ACTION values: always return 0
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t task_notify_take (bool clear_on_exit, uint32_t timeout)"
Waits for a notification to be nonzero\&.

.PP
See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for details\&.

.PP
\fBParameters\fP
.RS 4
\fIclear_on_exit\fP If true (1), then the notification value is cleared\&. If false (0), then the notification value is decremented\&. 
.br
\fItimeout\fP Specifies the amount of time to be spent waiting for a notification to occur\&.
.RE
.PP
\fBReturns\fP
.RS 4
The value of the task's notification value before it is decremented or cleared
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_resume (\fBtask_t\fP task)"
Resumes the specified task, making it eligible to be scheduled\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to resume
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_set_priority (\fBtask_t\fP task, uint32_t prio)"
Sets the priority of the specified task\&.

.PP
If the specified task's state is available to be scheduled (e\&.g\&. not blocked) and new priority is higher than the currently running task, a context switch may occur\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to set 
.br
\fIprio\fP The new priority of the task
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_suspend (\fBtask_t\fP task)"
Suspends the specified task, making it ineligible to be scheduled\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to suspend
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
