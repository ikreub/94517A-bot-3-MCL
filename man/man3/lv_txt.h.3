.TH "include/liblvgl/misc/lv_txt.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/misc/lv_txt.h
.SH SYNOPSIS
.br
.PP
\fR#include 'liblvgl/lv_conf_internal\&.h'\fP
.br
\fR#include <stdbool\&.h>\fP
.br
\fR#include <stdarg\&.h>\fP
.br
\fR#include 'lv_area\&.h'\fP
.br
\fR#include 'liblvgl/font/lv_font\&.h'\fP
.br
\fR#include 'lv_printf\&.h'\fP
.br
\fR#include 'lv_types\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLV_TXT_ENC_UTF8\fP   1"
.br
.ti -1c
.RI "#define \fBLV_TXT_ENC_ASCII\fP   2"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBlv_text_flag_t\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBlv_text_cmd_state_t\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBlv_text_align_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBLV_TEXT_FLAG_NONE\fP = 0x00, \fBLV_TEXT_FLAG_RECOLOR\fP = 0x01, \fBLV_TEXT_FLAG_EXPAND\fP = 0x02, \fBLV_TEXT_FLAG_FIT\fP = 0x04 }"
.br
.ti -1c
.RI "enum { \fBLV_TEXT_CMD_STATE_WAIT\fP, \fBLV_TEXT_CMD_STATE_PAR\fP, \fBLV_TEXT_CMD_STATE_IN\fP }"
.br
.ti -1c
.RI "enum { \fBLV_TEXT_ALIGN_AUTO\fP, \fBLV_TEXT_ALIGN_LEFT\fP, \fBLV_TEXT_ALIGN_CENTER\fP, \fBLV_TEXT_ALIGN_RIGHT\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlv_txt_get_size\fP (\fBlv_point_t\fP *size_res, const char *text, const \fBlv_font_t\fP *font, lv_coord_t letter_space, lv_coord_t line_space, lv_coord_t max_width, lv_text_flag_t flag)"
.br
.ti -1c
.RI "uint32_t \fB_lv_txt_get_next_line\fP (const char *txt, const \fBlv_font_t\fP *font, lv_coord_t letter_space, lv_coord_t max_width, lv_coord_t *used_width, lv_text_flag_t flag)"
.br
.ti -1c
.RI "lv_coord_t \fBlv_txt_get_width\fP (const char *txt, uint32_t length, const \fBlv_font_t\fP *font, lv_coord_t letter_space, lv_text_flag_t flag)"
.br
.ti -1c
.RI "bool \fB_lv_txt_is_cmd\fP (lv_text_cmd_state_t *state, uint32_t c)"
.br
.ti -1c
.RI "void \fB_lv_txt_ins\fP (char *txt_buf, uint32_t pos, const char *ins_txt)"
.br
.ti -1c
.RI "void \fB_lv_txt_cut\fP (char *txt, uint32_t pos, uint32_t len)"
.br
.ti -1c
.RI "char * \fB_lv_txt_set_text_vfmt\fP (const char *fmt, va_list ap) LV_FORMAT_ATTRIBUTE(1"
.br
.ti -1c
.RI "char void \fB_lv_txt_encoded_letter_next_2\fP (const char *txt, uint32_t *letter, uint32_t *letter_next, uint32_t *ofs)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "uint8_t(* \fB_lv_txt_encoded_size\fP )(const char *)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_unicode_to_encoded\fP )(uint32_t)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_encoded_conv_wc\fP )(uint32_t c)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_encoded_next\fP )(const char *, uint32_t *)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_encoded_prev\fP )(const char *, uint32_t *)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_encoded_get_byte_id\fP )(const char *, uint32_t)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_encoded_get_char_id\fP )(const char *, uint32_t)"
.br
.ti -1c
.RI "uint32_t(* \fB_lv_txt_get_encoded_length\fP )(const char *)"
.br
.in -1c
.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
Label align policy 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILV_TEXT_ALIGN_AUTO \fP
Align text auto 
.TP
\f(BILV_TEXT_ALIGN_LEFT \fP
Align text to left 
.TP
\f(BILV_TEXT_ALIGN_CENTER \fP
Align text to center 
.TP
\f(BILV_TEXT_ALIGN_RIGHT \fP
Align text to right 
.SS "anonymous enum"
State machine for text renderer\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILV_TEXT_CMD_STATE_WAIT \fP
Waiting for command 
.TP
\f(BILV_TEXT_CMD_STATE_PAR \fP
Processing the parameter 
.TP
\f(BILV_TEXT_CMD_STATE_IN \fP
Processing the command 
.SS "anonymous enum"
Options for text rendering\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\f(BILV_TEXT_FLAG_RECOLOR \fP
Enable parsing of recolor command 
.TP
\f(BILV_TEXT_FLAG_EXPAND \fP
Ignore max-width to avoid automatic word wrapping 
.TP
\f(BILV_TEXT_FLAG_FIT \fP
Max-width is already equal to the longest line\&. (Used to skip some calculation) 
.SH "Function Documentation"
.PP 
.SS "void _lv_txt_cut (char * txt, uint32_t pos, uint32_t len)"
Delete a part of a string 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP string to modify, must be '\\0' terminated and should point to a heap or stack frame, not read-only memory\&. 
.br
\fIpos\fP position where to start the deleting (0: before the first char, 1: after the first char etc\&.) 
.br
\fIlen\fP number of characters to delete 
.RE
.PP

.SS "char void _lv_txt_encoded_letter_next_2 (const char * txt, uint32_t * letter, uint32_t * letter_next, uint32_t * ofs)"
Decode two encoded character from a string\&. 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP pointer to '\\0' terminated string 
.br
\fIletter\fP the first decoded Unicode character or 0 on invalid data code 
.br
\fIletter_next\fP the second decoded Unicode character or 0 on invalid data code 
.br
\fIofs\fP start index in 'txt' where to start\&. After the call it will point to the next encoded char in 'txt'\&. NULL to use txt[0] as index 
.RE
.PP

.SS "uint32_t _lv_txt_get_next_line (const char * txt, const \fBlv_font_t\fP * font, lv_coord_t letter_space, lv_coord_t max_width, lv_coord_t * used_width, lv_text_flag_t flag)"
Get the next line of text\&. Check line length and break chars too\&. 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP a '\\0' terminated string 
.br
\fIfont\fP pointer to a font 
.br
\fIletter_space\fP letter space 
.br
\fImax_width\fP max width of the text (break the lines to fit this size)\&. Set COORD_MAX to avoid line breaks 
.br
\fIused_width\fP When used_width != NULL, save the width of this line if flag == LV_TEXT_FLAG_NONE, otherwise save -1\&. 
.br
\fIflags\fP settings for the text from 'txt_flag_type' enum 
.RE
.PP
\fBReturns\fP
.RS 4
the index of the first char of the new line (in byte index not letter index\&. With UTF-8 they are different) 
.RE
.PP

.SS "void _lv_txt_ins (char * txt_buf, uint32_t pos, const char * ins_txt)"
Insert a string into an other 
.PP
\fBParameters\fP
.RS 4
\fItxt_buf\fP the original text (must be big enough for the result text and NULL terminated) 
.br
\fIpos\fP position to insert (0: before the original text, 1: after the first char etc\&.) 
.br
\fIins_txt\fP text to insert, must be '\\0' terminated 
.RE
.PP

.SS "bool _lv_txt_is_cmd (lv_text_cmd_state_t * state, uint32_t c)"
Check next character in a string and decide if the character is part of the command or not 
.PP
\fBParameters\fP
.RS 4
\fIstate\fP pointer to a txt_cmd_state_t variable which stores the current state of command processing 
.br
\fIc\fP the current character 
.RE
.PP
\fBReturns\fP
.RS 4
true: the character is part of a command and should not be written, false: the character should be written 
.RE
.PP

.SS "char * _lv_txt_set_text_vfmt (const char * fmt, va_list ap)"
return a new formatted text\&. Memory will be allocated to store the text\&. 
.PP
\fBParameters\fP
.RS 4
\fIfmt\fP \fRprintf\fP-like format 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the allocated text string\&. 
.RE
.PP

.SS "void lv_txt_get_size (\fBlv_point_t\fP * size_res, const char * text, const \fBlv_font_t\fP * font, lv_coord_t letter_space, lv_coord_t line_space, lv_coord_t max_width, lv_text_flag_t flag)"
Get size of a text 
.PP
\fBParameters\fP
.RS 4
\fIsize_res\fP pointer to a 'point_t' variable to store the result 
.br
\fItext\fP pointer to a text 
.br
\fIfont\fP pointer to font of the text 
.br
\fIletter_space\fP letter space of the text 
.br
\fIline_space\fP line space of the text 
.br
\fIflags\fP settings for the text from lv_text_flag_t 
.br
\fImax_width\fP max width of the text (break the lines to fit this size)\&. Set COORD_MAX to avoid line breaks 
.RE
.PP

.SS "lv_coord_t lv_txt_get_width (const char * txt, uint32_t length, const \fBlv_font_t\fP * font, lv_coord_t letter_space, lv_text_flag_t flag)"
Give the length of a text with a given font 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP a '\\0' terminate string 
.br
\fIlength\fP length of 'txt' in byte count and not characters (Á is 1 character but 2 bytes in UTF-8) 
.br
\fIfont\fP pointer to a font 
.br
\fIletter_space\fP letter space 
.br
\fIflags\fP settings for the text from 'txt_flag_t' enum 
.RE
.PP
\fBReturns\fP
.RS 4
length of a char_num long text 
.RE
.PP

.SH "Variable Documentation"
.PP 
.SS "uint32_t(* _lv_txt_encoded_conv_wc) (uint32_t c) (uint32_t c)\fR [extern]\fP"
Convert a wide character, e\&.g\&. 'Á' little endian to be compatible with the encoded format\&. 
.PP
\fBParameters\fP
.RS 4
\fIc\fP a wide character 
.RE
.PP
\fBReturns\fP
.RS 4
\fRc\fP in the encoded format 
.RE
.PP

.SS "uint32_t(* _lv_txt_encoded_get_byte_id) (const char *, uint32_t) (const char * , uint32_t )\fR [extern]\fP"
Convert a letter index (in the encoded text) to byte index\&. E\&.g\&. in UTF-8 "AÁRT" index of 'R' is 2 but start at byte 3 because 'Á' is 2 bytes long 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP a '\\0' terminated UTF-8 string 
.br
\fIenc_id\fP letter index 
.RE
.PP
\fBReturns\fP
.RS 4
byte index of the 'enc_id'th letter 
.RE
.PP

.SS "uint32_t(* _lv_txt_encoded_get_char_id) (const char *, uint32_t) (const char * , uint32_t )\fR [extern]\fP"
Convert a byte index (in an encoded text) to character index\&. E\&.g\&. in UTF-8 "AÁRT" index of 'R' is 2 but start at byte 3 because 'Á' is 2 bytes long 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP a '\\0' terminated UTF-8 string 
.br
\fIbyte_id\fP byte index 
.RE
.PP
\fBReturns\fP
.RS 4
character index of the letter at 'byte_id'th position 
.RE
.PP

.SS "uint32_t(* _lv_txt_encoded_next) (const char *, uint32_t *) (const char * , uint32_t * )\fR [extern]\fP"
Decode the next encoded character from a string\&. 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP pointer to '\\0' terminated string 
.br
\fIi\fP start index in 'txt' where to start\&. After the call it will point to the next encoded char in 'txt'\&. NULL to use txt[0] as index 
.RE
.PP
\fBReturns\fP
.RS 4
the decoded Unicode character or 0 on invalid data code 
.RE
.PP

.SS "uint32_t(* _lv_txt_encoded_prev) (const char *, uint32_t *) (const char * , uint32_t * )\fR [extern]\fP"
Get the previous encoded character form a string\&. 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP pointer to '\\0' terminated string 
.br
\fIi_start\fP index in 'txt' where to start\&. After the call it will point to the previous encoded char in 'txt'\&. 
.RE
.PP
\fBReturns\fP
.RS 4
the decoded Unicode character or 0 on invalid data 
.RE
.PP

.SS "uint8_t(* _lv_txt_encoded_size) (const char *) (const char * )\fR [extern]\fP"
Give the size of an encoded character 
.PP
\fBParameters\fP
.RS 4
\fIstr\fP pointer to a character in a string 
.RE
.PP
\fBReturns\fP
.RS 4
length of the encoded character (1,2,3 \&.\&.\&.)\&. O in invalid 
.RE
.PP

.SS "uint32_t(* _lv_txt_get_encoded_length) (const char *) (const char * )\fR [extern]\fP"
Get the number of characters (and NOT bytes) in a string\&. E\&.g\&. in UTF-8 "ÁBC" is 3 characters (but 4 bytes) 
.PP
\fBParameters\fP
.RS 4
\fItxt\fP a '\\0' terminated char string 
.RE
.PP
\fBReturns\fP
.RS 4
number of characters 
.RE
.PP

.SS "uint32_t(* _lv_txt_unicode_to_encoded) (uint32_t) (uint32_t )\fR [extern]\fP"
Convert a Unicode letter to encoded 
.PP
\fBParameters\fP
.RS 4
\fIletter_uni\fP a Unicode letter 
.RE
.PP
\fBReturns\fP
.RS 4
Encoded character in Little Endian to be compatible with C chars (e\&.g\&. 'Á', 'Ü') 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
