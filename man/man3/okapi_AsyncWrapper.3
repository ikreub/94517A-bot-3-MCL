.TH "okapi::AsyncWrapper< Input, Output >" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
okapi::AsyncWrapper< Input, Output >
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBokapi::AsyncController< Input, Output >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAsyncWrapper\fP (const std::shared_ptr< \fBControllerInput\fP< Input > > &iinput, const std::shared_ptr< \fBControllerOutput\fP< Output > > &ioutput, const std::shared_ptr< \fBIterativeController\fP< Input, Output > > &icontroller, const \fBSupplier\fP< std::unique_ptr< \fBAbstractRate\fP > > &irateSupplier, const double iratio=1, std::shared_ptr< \fBLogger\fP > ilogger=\fBLogger::getDefaultLogger\fP())"
.br
.ti -1c
.RI "\fBAsyncWrapper\fP (AsyncWrapper< Input, Output > &&other)=delete"
.br
.ti -1c
.RI "\fBAsyncWrapper\fP< Input, Output > & \fBoperator=\fP (\fBAsyncWrapper\fP< Input, Output > &&other)=delete"
.br
.ti -1c
.RI "void \fBsetTarget\fP (const Input itarget) override"
.br
.ti -1c
.RI "void \fBcontrollerSet\fP (const Input ivalue) override"
.br
.ti -1c
.RI "Input \fBgetTarget\fP () override"
.br
.ti -1c
.RI "Input \fBgetProcessValue\fP () const override"
.br
.ti -1c
.RI "Output \fBgetOutput\fP () const"
.br
.ti -1c
.RI "Output \fBgetError\fP () const override"
.br
.ti -1c
.RI "bool \fBisSettled\fP () override"
.br
.ti -1c
.RI "void \fBsetSampleTime\fP (const QTime &isampleTime)"
.br
.ti -1c
.RI "void \fBsetOutputLimits\fP (const Output imax, const Output imin)"
.br
.ti -1c
.RI "void \fBsetControllerSetTargetLimits\fP (double itargetMax, double itargetMin)"
.br
.ti -1c
.RI "Output \fBgetMaxOutput\fP ()"
.br
.ti -1c
.RI "Output \fBgetMinOutput\fP ()"
.br
.ti -1c
.RI "void \fBreset\fP () override"
.br
.ti -1c
.RI "void \fBflipDisable\fP () override"
.br
.ti -1c
.RI "void \fBflipDisable\fP (const bool iisDisabled) override"
.br
.ti -1c
.RI "bool \fBisDisabled\fP () const override"
.br
.ti -1c
.RI "void \fBwaitUntilSettled\fP () override"
.br
.ti -1c
.RI "void \fBstartThread\fP ()"
.br
.ti -1c
.RI "\fBCrossplatformThread\fP * \fBgetThread\fP () const"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBloop\fP ()"
.br
.ti -1c
.RI "virtual void \fBresumeMovement\fP ()"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBtrampoline\fP (void *context)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBLogger\fP > \fBlogger\fP"
.br
.ti -1c
.RI "\fBSupplier\fP< std::unique_ptr< \fBAbstractRate\fP > > \fBrateSupplier\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBControllerInput\fP< Input > > \fBinput\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBControllerOutput\fP< Output > > \fBoutput\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBIterativeController\fP< Input, Output > > \fBcontroller\fP"
.br
.ti -1c
.RI "bool \fBhasFirstTarget\fP {false}"
.br
.ti -1c
.RI "Input \fBlastTarget\fP"
.br
.ti -1c
.RI "double \fBratio\fP"
.br
.ti -1c
.RI "std::atomic_bool \fBdtorCalled\fP {false}"
.br
.ti -1c
.RI "\fBCrossplatformThread\fP * \fBtask\fP {nullptr}"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename Input, typename Output> \fBokapi::AsyncWrapper\fP< Input, Output >::AsyncWrapper (const std::shared_ptr< \fBControllerInput\fP< Input > > & iinput, const std::shared_ptr< \fBControllerOutput\fP< Output > > & ioutput, const std::shared_ptr< \fBIterativeController\fP< Input, Output > > & icontroller, const \fBSupplier\fP< std::unique_ptr< \fBAbstractRate\fP > > & irateSupplier, const double iratio = \fR1\fP, std::shared_ptr< \fBLogger\fP > ilogger = \fR\fBLogger::getDefaultLogger\fP()\fP)\fR [inline]\fP"
A wrapper class that transforms an \fR\fBIterativeController\fP\fP into an \fR\fBAsyncController\fP\fP by running it in another task\&. The input controller will act like an \fR\fBAsyncController\fP\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIiinput\fP controller input, passed to the \fR\fBIterativeController\fP\fP 
.br
\fIioutput\fP controller output, written to from the \fR\fBIterativeController\fP\fP 
.br
\fIicontroller\fP the controller to use 
.br
\fIirateSupplier\fP used for rates used in the main loop and in \fR\fBwaitUntilSettled\fP\fP 
.br
\fIiratio\fP Any external gear ratio\&. 
.br
\fIilogger\fP The logger this instance will log to\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::controllerSet (const Input ivalue)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Writes the value of the controller output\&. This method might be automatically called in another thread by the controller\&.

.PP
\fBParameters\fP
.RS 4
\fIivalue\fP the controller's output 
.RE
.PP

.PP
Implements \fBokapi::ControllerOutput< Input >\fP\&.
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::flipDisable ()\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Changes whether the controller is off or on\&. Turning the controller on after it was off will cause the controller to move to its last set target, unless it was reset in that time\&. 
.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::flipDisable (const bool iisDisabled)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Sets whether the controller is off or on\&. Turning the controller on after it was off will cause the controller to move to its last set target, unless it was reset in that time\&.

.PP
\fBParameters\fP
.RS 4
\fIiisDisabled\fP whether the controller is disabled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> Output \fBokapi::AsyncWrapper\fP< Input, Output >::getError () const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Returns the last error of the controller\&. Does not update when disabled\&. 
.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> Output \fBokapi::AsyncWrapper\fP< Input, Output >::getMaxOutput ()\fR [inline]\fP"
Get the upper output bound\&.

.PP
\fBReturns\fP
.RS 4
the upper output bound 
.RE
.PP

.SS "template<typename Input, typename Output> Output \fBokapi::AsyncWrapper\fP< Input, Output >::getMinOutput ()\fR [inline]\fP"
Get the lower output bound\&.

.PP
\fBReturns\fP
.RS 4
the lower output bound 
.RE
.PP

.SS "template<typename Input, typename Output> Output \fBokapi::AsyncWrapper\fP< Input, Output >::getOutput () const\fR [inline]\fP"
Returns the last calculated output of the controller\&. 
.SS "template<typename Input, typename Output> Input \fBokapi::AsyncWrapper\fP< Input, Output >::getProcessValue () const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"

.PP
\fBReturns\fP
.RS 4
The most recent value of the process variable\&. 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> Input \fBokapi::AsyncWrapper\fP< Input, Output >::getTarget ()\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Gets the last set target, or the default target if none was set\&.

.PP
\fBReturns\fP
.RS 4
the last target 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> \fBCrossplatformThread\fP * \fBokapi::AsyncWrapper\fP< Input, Output >::getThread () const\fR [inline]\fP"
Returns the underlying thread handle\&.

.PP
\fBReturns\fP
.RS 4
The underlying thread handle\&. 
.RE
.PP

.SS "template<typename Input, typename Output> bool \fBokapi::AsyncWrapper\fP< Input, Output >::isDisabled () const\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Returns whether the controller is currently disabled\&.

.PP
\fBReturns\fP
.RS 4
whether the controller is currently disabled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> bool \fBokapi::AsyncWrapper\fP< Input, Output >::isSettled ()\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Returns whether the controller has settled at the target\&. Determining what settling means is implementation-dependent\&.

.PP
If the controller is disabled, this method must return true\&.

.PP
\fBReturns\fP
.RS 4
whether the controller is settled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::reset ()\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Resets the controller's internal state so it is similar to when it was first initialized, while keeping any user-configured information\&. 
.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> virtual void \fBokapi::AsyncWrapper\fP< Input, Output >::resumeMovement ()\fR [inline]\fP, \fR [protected]\fP, \fR [virtual]\fP"
Resumes moving after the controller is reset\&. Should not cause movement if the controller is turned off, reset, and turned back on\&. 
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::setControllerSetTargetLimits (double itargetMax, double itargetMin)\fR [inline]\fP"
Sets the (soft) limits for the target range that \fBcontrollerSet()\fP scales into\&. The target computed by \fBcontrollerSet()\fP is scaled into the range [-itargetMin, itargetMax]\&.

.PP
\fBParameters\fP
.RS 4
\fIitargetMax\fP The new max target for \fBcontrollerSet()\fP\&. 
.br
\fIitargetMin\fP The new min target for \fBcontrollerSet()\fP\&. 
.RE
.PP

.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::setOutputLimits (const Output imax, const Output imin)\fR [inline]\fP"
Set controller output bounds\&.

.PP
\fBParameters\fP
.RS 4
\fIimax\fP max output 
.br
\fIimin\fP min output 
.RE
.PP

.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::setSampleTime (const QTime & isampleTime)\fR [inline]\fP"
Set time between loops\&.

.PP
\fBParameters\fP
.RS 4
\fIisampleTime\fP time between loops 
.RE
.PP

.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::setTarget (const Input itarget)\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Sets the target for the controller\&. 
.PP
Implements \fBokapi::ClosedLoopController< Input, Output >\fP\&.
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::startThread ()\fR [inline]\fP"
Starts the internal thread\&. This should not be called by normal users\&. This method is called by the AsyncControllerFactory when making a new instance of this class\&. 
.SS "template<typename Input, typename Output> void \fBokapi::AsyncWrapper\fP< Input, Output >::waitUntilSettled ()\fR [inline]\fP, \fR [override]\fP, \fR [virtual]\fP"
Blocks the current task until the controller has settled\&. Determining what settling means is implementation-dependent\&. 
.PP
Implements \fBokapi::AsyncController< Input, Output >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
