.TH "ez::Drive" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ez::Drive
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBconst_and_name\fP"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "void \fBslew_swing_constants_set\fP (okapi::QLength distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_swing_constants_forward_set\fP (okapi::QLength distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_swing_constants_backward_set\fP (okapi::QLength distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_swing_constants_set\fP (okapi::QAngle distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_swing_constants_forward_set\fP (okapi::QAngle distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_swing_constants_backward_set\fP (okapi::QAngle distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_turn_constants_set\fP (okapi::QAngle distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_drive_constants_forward_set\fP (okapi::QLength distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_drive_constants_backward_set\fP (okapi::QLength distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_drive_constants_set\fP (okapi::QLength distance, int min_speed)"
.br
.ti -1c
.RI "void \fBslew_drive_set\fP (bool slew_on)"
.br
.ti -1c
.RI "void \fBslew_drive_forward_set\fP (bool slew_on)"
.br
.ti -1c
.RI "bool \fBslew_drive_forward_get\fP ()"
.br
.ti -1c
.RI "void \fBslew_drive_backward_set\fP (bool slew_on)"
.br
.ti -1c
.RI "bool \fBslew_drive_backward_get\fP ()"
.br
.ti -1c
.RI "void \fBslew_swing_set\fP (bool slew_on)"
.br
.ti -1c
.RI "void \fBslew_swing_forward_set\fP (bool slew_on)"
.br
.ti -1c
.RI "bool \fBslew_swing_forward_get\fP ()"
.br
.ti -1c
.RI "void \fBslew_swing_backward_set\fP (bool slew_on)"
.br
.ti -1c
.RI "bool \fBslew_swing_backward_get\fP ()"
.br
.ti -1c
.RI "void \fBslew_turn_set\fP (bool slew_on)"
.br
.ti -1c
.RI "bool \fBslew_turn_get\fP ()"
.br
.ti -1c
.RI "void \fBslew_odom_reenable\fP (bool reenable)"
.br
.ti -1c
.RI "bool \fBslew_odom_reenabled\fP ()"
.br
.ti -1c
.RI "void \fBdrive_mode_set\fP (e_mode p_mode, bool stop_drive=true)"
.br
.ti -1c
.RI "e_mode \fBdrive_mode_get\fP ()"
.br
.ti -1c
.RI "void \fBinitialize\fP ()"
.br
.ti -1c
.RI "\fBDrive\fP (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ticks, double ratio=1\&.0)"
.br
.ti -1c
.RI "\fBDrive\fP (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ticks, double ratio, std::vector< int > left_tracker_ports, std::vector< int > right_tracker_ports) \fB__attribute__\fP((deprecated('Use the integrated encoder const ructor with \fBodom_tracker_left_set\fP() and \fBodom_tracker_right_set\fP() instead!')))"
.br
.ti -1c
.RI "\fBDrive\fP (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ticks, double ratio, std::vector< int > left_tracker_ports, std::vector< int > right_tracker_ports, int expander_smart_port) \fB__attribute__\fP((deprecated('Use the integrated encoder const ructor with \fBodom_tracker_left_set\fP() and \fBodom_tracker_right_set\fP() instead!')))"
.br
.ti -1c
.RI "\fBDrive\fP (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ratio, int left_rotation_port, int right_rotation_port) \fB__attribute__\fP((deprecated('Use the integrated encoder const ructor with \fBodom_tracker_left_set\fP() and \fBodom_tracker_right_set\fP() instead!')))"
.br
.ti -1c
.RI "void \fBdrive_defaults_set\fP ()"
.br
.ti -1c
.RI "void \fBez_tracking_task\fP ()"
.br
.ti -1c
.RI "void \fBodom_enable\fP (bool input)"
.br
.ti -1c
.RI "bool \fBodom_enabled\fP ()"
.br
.ti -1c
.RI "void \fBdrive_width_set\fP (double input)"
.br
.ti -1c
.RI "void \fBdrive_width_set\fP (okapi::QLength p_input)"
.br
.ti -1c
.RI "double \fBdrive_width_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_x_set\fP (double x)"
.br
.ti -1c
.RI "void \fBodom_x_set\fP (okapi::QLength p_x)"
.br
.ti -1c
.RI "double \fBodom_x_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_y_set\fP (double y)"
.br
.ti -1c
.RI "void \fBodom_y_set\fP (okapi::QLength p_y)"
.br
.ti -1c
.RI "double \fBodom_y_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_theta_set\fP (double a)"
.br
.ti -1c
.RI "void \fBodom_theta_set\fP (okapi::QAngle p_a)"
.br
.ti -1c
.RI "double \fBodom_theta_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_pose_set\fP (\fBpose\fP itarget)"
.br
.ti -1c
.RI "void \fBodom_pose_set\fP (\fBunited_pose\fP itarget)"
.br
.ti -1c
.RI "void \fBodom_xy_set\fP (double x, double y)"
.br
.ti -1c
.RI "void \fBodom_xy_set\fP (okapi::QLength p_x, okapi::QLength p_y)"
.br
.ti -1c
.RI "void \fBodom_xyt_set\fP (double x, double y, double t)"
.br
.ti -1c
.RI "void \fBodom_xyt_set\fP (okapi::QLength p_x, okapi::QLength p_y, okapi::QAngle p_t)"
.br
.ti -1c
.RI "\fBpose\fP \fBodom_pose_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_reset\fP ()"
.br
.ti -1c
.RI "void \fBodom_x_flip\fP (bool flip=true)"
.br
.ti -1c
.RI "bool \fBodom_x_direction_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_y_flip\fP (bool flip=true)"
.br
.ti -1c
.RI "bool \fBodom_y_direction_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_theta_flip\fP (bool flip=true)"
.br
.ti -1c
.RI "bool \fBodom_theta_direction_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_boomerang_dlead_set\fP (double input)"
.br
.ti -1c
.RI "double \fBodom_boomerang_dlead_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_boomerang_distance_set\fP (double distance)"
.br
.ti -1c
.RI "void \fBodom_boomerang_distance_set\fP (okapi::QLength p_distance)"
.br
.ti -1c
.RI "double \fBodom_boomerang_distance_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_turn_bias_set\fP (double bias)"
.br
.ti -1c
.RI "double \fBodom_turn_bias_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_path_spacing_set\fP (double spacing)"
.br
.ti -1c
.RI "void \fBodom_path_spacing_set\fP (okapi::QLength p_spacing)"
.br
.ti -1c
.RI "double \fBodom_path_spacing_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_path_smooth_constants_set\fP (double weight_smooth, double weight_data, double tolerance)"
.br
.ti -1c
.RI "std::vector< double > \fBodom_path_smooth_constants_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_path_print\fP ()"
.br
.ti -1c
.RI "void \fBodom_look_ahead_set\fP (double distance)"
.br
.ti -1c
.RI "void \fBodom_look_ahead_set\fP (okapi::QLength p_distance)"
.br
.ti -1c
.RI "double \fBodom_look_ahead_get\fP ()"
.br
.ti -1c
.RI "void \fBodom_tracker_left_set\fP (\fBtracking_wheel\fP *input)"
.br
.ti -1c
.RI "void \fBodom_tracker_right_set\fP (\fBtracking_wheel\fP *input)"
.br
.ti -1c
.RI "void \fBodom_tracker_front_set\fP (\fBtracking_wheel\fP *input)"
.br
.ti -1c
.RI "void \fBodom_tracker_back_set\fP (\fBtracking_wheel\fP *input)"
.br
.ti -1c
.RI "void \fBpid_angle_behavior_set\fP (e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_behavior_set\fP (e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_behavior_set\fP (e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_odom_behavior_set\fP (e_angle_behavior behavior)"
.br
.ti -1c
.RI "e_angle_behavior \fBpid_turn_behavior_get\fP ()"
.br
.ti -1c
.RI "e_angle_behavior \fBpid_swing_behavior_get\fP ()"
.br
.ti -1c
.RI "e_angle_behavior \fBpid_odom_behavior_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_angle_behavior_tolerance_set\fP (okapi::QAngle p_tolerance)"
.br
.ti -1c
.RI "void \fBpid_angle_behavior_tolerance_set\fP (double tolerance)"
.br
.ti -1c
.RI "double \fBpid_angle_behavior_tolerance_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_angle_behavior_bias_set\fP (e_angle_behavior behavior)"
.br
.ti -1c
.RI "e_angle_behavior \fBpid_angle_behavior_bias_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_tank\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_arcade_standard\fP (e_type stick_type)"
.br
.ti -1c
.RI "void \fBopcontrol_arcade_flipped\fP (e_type stick_type)"
.br
.ti -1c
.RI "void \fBopcontrol_curve_sd_initialize\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_curve_default_set\fP (double left, double right=0)"
.br
.ti -1c
.RI "std::vector< double > \fBopcontrol_curve_default_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_drive_activebrake_set\fP (double kp, double ki=0\&.0, double kd=0\&.0, double start_i=0\&.0)"
.br
.ti -1c
.RI "double \fBopcontrol_drive_activebrake_get\fP ()"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBopcontrol_drive_activebrake_constants_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_curve_buttons_toggle\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBopcontrol_curve_buttons_toggle_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_curve_buttons_left_set\fP (pros::controller_digital_e_t decrease, pros::controller_digital_e_t increase)"
.br
.ti -1c
.RI "std::vector< pros::controller_digital_e_t > \fBopcontrol_curve_buttons_left_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_curve_buttons_right_set\fP (pros::controller_digital_e_t decrease, pros::controller_digital_e_t increase)"
.br
.ti -1c
.RI "std::vector< pros::controller_digital_e_t > \fBopcontrol_curve_buttons_right_get\fP ()"
.br
.ti -1c
.RI "double \fBopcontrol_curve_left\fP (double x)"
.br
.ti -1c
.RI "double \fBopcontrol_curve_right\fP (double x)"
.br
.ti -1c
.RI "void \fBopcontrol_joystick_threshold_set\fP (int threshold)"
.br
.ti -1c
.RI "int \fBopcontrol_joystick_threshold_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_drive_sensors_reset\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_joystick_threshold_iterate\fP (int l_stick, int r_stick)"
.br
.ti -1c
.RI "bool \fBpto_check\fP (\fBpros::Motor\fP check_if_pto)"
.br
.ti -1c
.RI "void \fBpto_add\fP (std::vector< \fBpros::Motor\fP > pto_list)"
.br
.ti -1c
.RI "void \fBpto_remove\fP (std::vector< \fBpros::Motor\fP > pto_list)"
.br
.ti -1c
.RI "void \fBpto_toggle\fP (std::vector< \fBpros::Motor\fP > pto_list, bool toggle)"
.br
.ti -1c
.RI "void \fBdrive_set\fP (int left, int right)"
.br
.ti -1c
.RI "std::vector< int > \fBdrive_get\fP ()"
.br
.ti -1c
.RI "void \fBdrive_brake_set\fP (pros::motor_brake_mode_e_t brake_type)"
.br
.ti -1c
.RI "pros::motor_brake_mode_e_t \fBdrive_brake_get\fP ()"
.br
.ti -1c
.RI "void \fBdrive_current_limit_set\fP (int mA)"
.br
.ti -1c
.RI "int \fBdrive_current_limit_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_drive_toggle\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBpid_drive_toggle_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_print_toggle\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBpid_print_toggle_get\fP ()"
.br
.ti -1c
.RI "double \fBdrive_sensor_right\fP ()"
.br
.ti -1c
.RI "int \fBdrive_sensor_right_raw\fP ()"
.br
.ti -1c
.RI "int \fBdrive_velocity_right\fP ()"
.br
.ti -1c
.RI "double \fBdrive_mA_right\fP ()"
.br
.ti -1c
.RI "bool \fBdrive_current_right_over\fP ()"
.br
.ti -1c
.RI "double \fBdrive_sensor_left\fP ()"
.br
.ti -1c
.RI "int \fBdrive_sensor_left_raw\fP ()"
.br
.ti -1c
.RI "int \fBdrive_velocity_left\fP ()"
.br
.ti -1c
.RI "double \fBdrive_mA_left\fP ()"
.br
.ti -1c
.RI "bool \fBdrive_current_left_over\fP ()"
.br
.ti -1c
.RI "void \fBdrive_sensor_reset\fP ()"
.br
.ti -1c
.RI "void \fBdrive_imu_reset\fP (double new_heading=0)"
.br
.ti -1c
.RI "double \fBdrive_imu_get\fP ()"
.br
.ti -1c
.RI "double \fBdrive_imu_accel_get\fP ()"
.br
.ti -1c
.RI "void \fBdrive_imu_scaler_set\fP (double scaler)"
.br
.ti -1c
.RI "double \fBdrive_imu_scaler_get\fP ()"
.br
.ti -1c
.RI "bool \fBdrive_imu_calibrate\fP (bool run_loading_animation=true)"
.br
.ti -1c
.RI "bool \fBdrive_imu_calibrated\fP ()"
.br
.ti -1c
.RI "void \fBdrive_imu_display_loading\fP (int iter)"
.br
.ti -1c
.RI "void \fBopcontrol_joystick_practicemode_toggle\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBopcontrol_joystick_practicemode_toggle_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_drive_reverse_set\fP (bool toggle)"
.br
.ti -1c
.RI "bool \fBopcontrol_drive_reverse_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (double target, int speed)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (double target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (okapi::QLength p_target, int speed)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (okapi::QLength p_target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (\fBodom\fP imovement)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (\fBodom\fP imovement, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_ptp_set\fP (\fBodom\fP imovement)"
.br
.ti -1c
.RI "void \fBpid_odom_ptp_set\fP (\fBodom\fP imovement, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_boomerang_set\fP (\fBodom\fP imovement)"
.br
.ti -1c
.RI "void \fBpid_odom_boomerang_set\fP (\fBodom\fP imovement, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_boomerang_set\fP (\fBunited_odom\fP p_imovement)"
.br
.ti -1c
.RI "void \fBpid_odom_boomerang_set\fP (\fBunited_odom\fP p_imovement, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_ptp_set\fP (\fBunited_odom\fP p_imovement)"
.br
.ti -1c
.RI "void \fBpid_odom_ptp_set\fP (\fBunited_odom\fP p_imovement, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (\fBunited_odom\fP p_imovement)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (\fBunited_odom\fP p_imovement, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (std::vector< \fBodom\fP > imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (std::vector< \fBodom\fP > imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_pp_set\fP (std::vector< \fBodom\fP > imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_pp_set\fP (std::vector< \fBodom\fP > imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_injected_pp_set\fP (std::vector< \fBodom\fP > imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_injected_pp_set\fP (std::vector< \fBodom\fP > imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_smooth_pp_set\fP (std::vector< \fBodom\fP > imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_smooth_pp_set\fP (std::vector< \fBodom\fP > imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_smooth_pp_set\fP (std::vector< \fBunited_odom\fP > p_imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_smooth_pp_set\fP (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_injected_pp_set\fP (std::vector< \fBunited_odom\fP > p_imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_injected_pp_set\fP (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_pp_set\fP (std::vector< \fBunited_odom\fP > p_imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_pp_set\fP (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (std::vector< \fBunited_odom\fP > p_imovements)"
.br
.ti -1c
.RI "void \fBpid_odom_set\fP (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_drive_set\fP (okapi::QLength p_target, int speed)"
.br
.ti -1c
.RI "void \fBpid_drive_set\fP (okapi::QLength p_target, int speed, bool slew_on, bool toggle_heading=true)"
.br
.ti -1c
.RI "void \fBpid_drive_set\fP (double target, int speed)"
.br
.ti -1c
.RI "void \fBpid_drive_set\fP (double target, int speed, bool slew_on, bool toggle_heading=true)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBpose\fP itarget, drive_directions dir, int speed)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBpose\fP itarget, drive_directions dir, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBpose\fP itarget, drive_directions dir, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBpose\fP itarget, drive_directions dir, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBunited_pose\fP p_itarget, drive_directions dir, int speed)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBunited_pose\fP p_itarget, drive_directions dir, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBunited_pose\fP p_itarget, drive_directions dir, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (\fBunited_pose\fP p_itarget, drive_directions dir, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (double target, int speed)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (double target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (double target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (double target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (okapi::QAngle p_target, int speed)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (okapi::QAngle p_target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_set\fP (okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (okapi::QAngle p_target, int speed)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (okapi::QAngle p_target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (double target, int speed)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (double target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (double target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_turn_relative_set\fP (double target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, int opposite_speed)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, int opposite_speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, int opposite_speed)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, int opposite_speed, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_swing_relative_set\fP (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
.br
.ti -1c
.RI "void \fBpid_targets_reset\fP ()"
.br
.ti -1c
.RI "void \fBdrive_angle_set\fP (okapi::QAngle p_angle)"
.br
.ti -1c
.RI "void \fBdrive_angle_set\fP (double angle)"
.br
.ti -1c
.RI "void \fBpid_wait\fP ()"
.br
.ti -1c
.RI "void \fBpid_wait_until\fP (okapi::QAngle target)"
.br
.ti -1c
.RI "void \fBpid_wait_until\fP (okapi::QLength target)"
.br
.ti -1c
.RI "void \fBpid_wait_until\fP (double target)"
.br
.ti -1c
.RI "void \fBpid_wait_quick\fP ()"
.br
.ti -1c
.RI "void \fBpid_wait_quick_chain\fP ()"
.br
.ti -1c
.RI "void \fBpid_wait_until_index\fP (int index)"
.br
.ti -1c
.RI "void \fBpid_wait_until_index_started\fP (int index)"
.br
.ti -1c
.RI "void \fBpid_wait_until_point\fP (\fBpose\fP target)"
.br
.ti -1c
.RI "void \fBpid_wait_until_point\fP (\fBunited_pose\fP target)"
.br
.ti -1c
.RI "void \fBpid_wait_until\fP (\fBpose\fP target)"
.br
.ti -1c
.RI "void \fBpid_wait_until\fP (\fBunited_pose\fP target)"
.br
.ti -1c
.RI "void \fBdrive_ratio_set\fP (double ratio)"
.br
.ti -1c
.RI "void \fBdrive_rpm_set\fP (double rpm)"
.br
.ti -1c
.RI "double \fBdrive_ratio_get\fP ()"
.br
.ti -1c
.RI "double \fBdrive_rpm_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_speed_max_set\fP (int speed)"
.br
.ti -1c
.RI "int \fBpid_speed_max_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_turn_constants_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_turn_constants_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_turn_chain_constant_set\fP (okapi::QAngle input)"
.br
.ti -1c
.RI "void \fBpid_turn_chain_constant_set\fP (double input)"
.br
.ti -1c
.RI "double \fBpid_turn_chain_constant_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_swing_constants_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_swing_constants_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_swing_constants_forward_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_swing_constants_forward_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_swing_constants_backward_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_swing_constants_backward_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_swing_chain_constant_set\fP (okapi::QAngle input)"
.br
.ti -1c
.RI "void \fBpid_swing_chain_forward_constant_set\fP (okapi::QAngle input)"
.br
.ti -1c
.RI "void \fBpid_swing_chain_backward_constant_set\fP (okapi::QAngle input)"
.br
.ti -1c
.RI "void \fBpid_swing_chain_constant_set\fP (double input)"
.br
.ti -1c
.RI "void \fBpid_swing_chain_forward_constant_set\fP (double input)"
.br
.ti -1c
.RI "double \fBpid_swing_chain_forward_constant_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_swing_chain_backward_constant_set\fP (double input)"
.br
.ti -1c
.RI "double \fBpid_swing_chain_backward_constant_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_heading_constants_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_heading_constants_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_drive_constants_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_drive_constants_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_drive_constants_forward_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_drive_constants_forward_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_drive_constants_backward_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "\fBPID::Constants\fP \fBpid_drive_constants_backward_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_drive_chain_constant_set\fP (okapi::QLength input)"
.br
.ti -1c
.RI "void \fBpid_drive_chain_forward_constant_set\fP (okapi::QLength input)"
.br
.ti -1c
.RI "void \fBpid_drive_chain_backward_constant_set\fP (okapi::QLength input)"
.br
.ti -1c
.RI "void \fBpid_drive_chain_constant_set\fP (double input)"
.br
.ti -1c
.RI "void \fBpid_drive_chain_forward_constant_set\fP (double input)"
.br
.ti -1c
.RI "double \fBpid_drive_chain_forward_constant_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_drive_chain_backward_constant_set\fP (double input)"
.br
.ti -1c
.RI "double \fBpid_drive_chain_backward_constant_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_swing_min_set\fP (int min)"
.br
.ti -1c
.RI "void \fBpid_turn_min_set\fP (int min)"
.br
.ti -1c
.RI "int \fBpid_swing_min_get\fP ()"
.br
.ti -1c
.RI "int \fBpid_turn_min_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_odom_angular_constants_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "void \fBpid_odom_boomerang_constants_set\fP (double p, double i=0\&.0, double d=0\&.0, double p_start_i=0\&.0)"
.br
.ti -1c
.RI "void \fBpid_odom_drive_exit_condition_set\fP (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_odom_turn_exit_condition_set\fP (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_odom_turn_exit_condition_set\fP (okapi::QTime p_small_exit_time, okapi::QAngle p_small_error, okapi::QTime p_big_exit_time, okapi::QAngle p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_odom_drive_exit_condition_set\fP (okapi::QTime p_small_exit_time, okapi::QLength p_small_error, okapi::QTime p_big_exit_time, okapi::QLength p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_drive_exit_condition_set\fP (okapi::QTime p_small_exit_time, okapi::QLength p_small_error, okapi::QTime p_big_exit_time, okapi::QLength p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_turn_exit_condition_set\fP (okapi::QTime p_small_exit_time, okapi::QAngle p_small_error, okapi::QTime p_big_exit_time, okapi::QAngle p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_swing_exit_condition_set\fP (okapi::QTime p_small_exit_time, okapi::QAngle p_small_error, okapi::QTime p_big_exit_time, okapi::QAngle p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_drive_exit_condition_set\fP (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_turn_exit_condition_set\fP (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "void \fBpid_swing_exit_condition_set\fP (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu=true)"
.br
.ti -1c
.RI "double \fBdrive_tick_per_inch\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_curve_buttons_iterate\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_enable\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_disable\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_toggle\fP ()"
.br
.ti -1c
.RI "bool \fBpid_tuner_enabled\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_iterate\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_print_brain_set\fP (bool input)"
.br
.ti -1c
.RI "void \fBpid_tuner_print_terminal_set\fP (bool input)"
.br
.ti -1c
.RI "bool \fBpid_tuner_print_terminal_enabled\fP ()"
.br
.ti -1c
.RI "bool \fBpid_tuner_print_brain_enabled\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_increment_p_set\fP (double p)"
.br
.ti -1c
.RI "void \fBpid_tuner_increment_i_set\fP (double i)"
.br
.ti -1c
.RI "void \fBpid_tuner_increment_d_set\fP (double d)"
.br
.ti -1c
.RI "void \fBpid_tuner_increment_start_i_set\fP (double start_i)"
.br
.ti -1c
.RI "double \fBpid_tuner_increment_p_get\fP ()"
.br
.ti -1c
.RI "double \fBpid_tuner_increment_i_get\fP ()"
.br
.ti -1c
.RI "double \fBpid_tuner_increment_d_get\fP ()"
.br
.ti -1c
.RI "double \fBpid_tuner_increment_start_i_get\fP ()"
.br
.ti -1c
.RI "void \fBpid_tuner_full_enable\fP (bool enable)"
.br
.ti -1c
.RI "bool \fBpid_tuner_full_enabled\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_speed_max_set\fP (int speed)"
.br
.ti -1c
.RI "int \fBopcontrol_speed_max_get\fP ()"
.br
.ti -1c
.RI "void \fBopcontrol_arcade_scaling\fP (bool enable)"
.br
.ti -1c
.RI "bool \fBopcontrol_arcade_scaling_enabled\fP ()"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "int \fBJOYSTICK_THRESHOLD\fP"
.br
.ti -1c
.RI "pros::motor_brake_mode_e_t \fBCURRENT_BRAKE\fP = pros::E_MOTOR_BRAKE_COAST"
.br
.ti -1c
.RI "int \fBCURRENT_MA\fP = 2500"
.br
.ti -1c
.RI "e_swing \fBcurrent_swing\fP"
.br
.ti -1c
.RI "std::vector< \fBpros::Motor\fP > \fBleft_motors\fP"
.br
.ti -1c
.RI "std::vector< \fBpros::Motor\fP > \fBright_motors\fP"
.br
.ti -1c
.RI "std::vector< int > \fBpto_active\fP"
.br
.ti -1c
.RI "\fBpros::Imu\fP \fBimu\fP"
.br
.ti -1c
.RI "\fBpros::adi::Encoder\fP \fBleft_tracker\fP"
.br
.ti -1c
.RI "\fBpros::adi::Encoder\fP \fBright_tracker\fP"
.br
.ti -1c
.RI "\fBpros::Rotation\fP \fBleft_rotation\fP"
.br
.ti -1c
.RI "\fBpros::Rotation\fP \fBright_rotation\fP"
.br
.ti -1c
.RI "\fBtracking_wheel\fP * \fBodom_tracker_left\fP"
.br
.ti -1c
.RI "\fBtracking_wheel\fP * \fBodom_tracker_right\fP"
.br
.ti -1c
.RI "\fBtracking_wheel\fP * \fBodom_tracker_front\fP"
.br
.ti -1c
.RI "\fBtracking_wheel\fP * \fBodom_tracker_back\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBheadingPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBturnPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBleftPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBrightPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBforward_drivePID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBbackward_drivePID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBfwd_rev_drivePID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBswingPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBforward_swingPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBbackward_swingPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBfwd_rev_swingPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBxyPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBcurrent_a_odomPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBboomerangPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBodom_angularPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBinternal_leftPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBinternal_rightPID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBleft_activebrakePID\fP"
.br
.ti -1c
.RI "\fBPID\fP \fBright_activebrakePID\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_left\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_right\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_forward\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_backward\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_turn\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_swing_forward\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_swing_backward\fP"
.br
.ti -1c
.RI "\fBez::slew\fP \fBslew_swing\fP"
.br
.ti -1c
.RI "e_mode \fBmode\fP"
.br
.ti -1c
.RI "\fBpros::Task\fP \fBez_auto\fP"
.br
.ti -1c
.RI "bool \fBinterfered\fP = false"
.br
.ti -1c
.RI "std::vector< \fBconst_and_name\fP > \fBpid_tuner_pids\fP"
.br
.ti -1c
.RI "std::vector< \fBconst_and_name\fP > \fBpid_tuner_full_pids\fP"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "ez::Drive::Drive (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ticks, double ratio = \fR1\&.0\fP)"
Creates a \fBDrive\fP Controller using internal encoders\&.

.PP
\fBParameters\fP
.RS 4
\fIleft_motor_ports\fP input {1, -2\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIright_motor_ports\fP input {-3, 4\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIimu_port\fP port the IMU is plugged into 
.br
\fIwheel_diameter\fP diameter of your drive wheels 
.br
\fIticks\fP motor cartridge RPM 
.br
\fIratio\fP external gear ratio, wheel gear / motor gear 
.RE
.PP

.SS "ez::Drive::Drive (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ticks, double ratio, std::vector< int > left_tracker_ports, std::vector< int > right_tracker_ports) const"
Creates a \fBDrive\fP Controller using encoders plugged into the brain\&.

.PP
\fBParameters\fP
.RS 4
\fIleft_motor_ports\fP input {1, -2\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIright_motor_ports\fP input {-3, 4\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIimu_port\fP port the IMU is plugged into 
.br
\fIwheel_diameter\fP diameter of your sensored wheel 
.br
\fIticks\fP ticks per revolution of your encoder 
.br
\fIratio\fP external gear ratio, wheel gear / sensor gear 
.br
\fIleft_tracker_ports\fP input {1, 2}\&. make ports negative if reversed 
.br
\fIright_tracker_ports\fP input {3, 4}\&. make ports negative if reversed 
.RE
.PP

.SS "ez::Drive::Drive (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ticks, double ratio, std::vector< int > left_tracker_ports, std::vector< int > right_tracker_ports, int expander_smart_port) const"
Creates a \fBDrive\fP Controller using encoders plugged into a 3 wire expander\&.

.PP
\fBParameters\fP
.RS 4
\fIleft_motor_ports\fP input {1, -2\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIright_motor_ports\fP input {-3, 4\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIimu_port\fP port the IMU is plugged into 
.br
\fIwheel_diameter\fP diameter of your sensored wheel 
.br
\fIticks\fP ticks per revolution of your encoder 
.br
\fIratio\fP external gear ratio, wheel gear / sensor gear 
.br
\fIleft_tracker_ports\fP input {1, 2}\&. make ports negative if reversed 
.br
\fIright_tracker_ports\fP input {3, 4}\&. make ports negative if reversed 
.br
\fIexpander_smart_port\fP port the expander is plugged into 
.RE
.PP

.SS "ez::Drive::Drive (std::vector< int > left_motor_ports, std::vector< int > right_motor_ports, int imu_port, double wheel_diameter, double ratio, int left_rotation_port, int right_rotation_port) const"
Creates a \fBDrive\fP Controller using rotation sensors\&.

.PP
\fBParameters\fP
.RS 4
\fIleft_motor_ports\fP input {1, -2\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIright_motor_ports\fP input {-3, 4\&.\&.\&.}\&. make ports negative if reversed 
.br
\fIimu_port\fP port the IMU is plugged into 
.br
\fIwheel_diameter\fP diameter of your sensored wheel 
.br
\fIratio\fP external gear ratio, wheel gear / sensor gear 
.br
\fIleft_tracker_port\fP make ports negative if reversed 
.br
\fIright_tracker_port\fP make ports negative if reversed 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void ez::Drive::drive_angle_set (double angle)"
Sets heading of imu and target of \fBPID\fP, takes double as an angle\&. 
.SS "void ez::Drive::drive_angle_set (okapi::QAngle p_angle)"
Sets heading of imu and target of \fBPID\fP, okapi angle\&. 
.SS "pros::motor_brake_mode_e_t ez::Drive::drive_brake_get ()"
Returns the brake mode of the drive in pros_brake_mode_e_t_\&. 
.SS "void ez::Drive::drive_brake_set (pros::motor_brake_mode_e_t brake_type)"
Changes the way the drive behaves when it is not under active user control\&.

.PP
\fBParameters\fP
.RS 4
\fIbrake_type\fP the 'brake mode' of the motor e\&.g\&. 'pros::E_MOTOR_BRAKE_COAST' 'pros::E_MOTOR_BRAKE_BRAKE' 'pros::E_MOTOR_BRAKE_HOLD' 
.RE
.PP

.SS "bool ez::Drive::drive_current_left_over ()"
Return true when the motor is over current\&. 
.SS "int ez::Drive::drive_current_limit_get ()"
Gets the limit for the current on the drive\&. 
.SS "void ez::Drive::drive_current_limit_set (int mA)"
Sets the limit for the current on the drive\&.

.PP
\fBParameters\fP
.RS 4
\fImA\fP input in milliamps 
.RE
.PP

.SS "bool ez::Drive::drive_current_right_over ()"
Return true when the motor is over current\&. 
.SS "void ez::Drive::drive_defaults_set ()"
Sets drive defaults\&. 
.SS "std::vector< int > ez::Drive::drive_get ()"
Gets the chassis to voltage, -127 to 127\&. Returns {left, right}\&. 
.SS "double ez::Drive::drive_imu_accel_get ()"
Returns the current imu accel x + accel y value\&. 
.SS "bool ez::Drive::drive_imu_calibrate (bool run_loading_animation = \fRtrue\fP)"
Calibrates the IMU, recommended to run in \fBinitialize()\fP\&.

.PP
\fBParameters\fP
.RS 4
\fIrun_loading_animation\fP true runs the animation, false doesn't 
.RE
.PP

.SS "bool ez::Drive::drive_imu_calibrated ()"
Checks if the imu calibrated successfully or if it took longer than expected\&.

.PP
Returns true if calibrated successfully, and false if unsuccessful\&. 
.SS "void ez::Drive::drive_imu_display_loading (int iter)"
Loading display while the IMU calibrates\&. 
.SS "double ez::Drive::drive_imu_get ()"
Returns the current imu rotation value in degrees\&. 
.SS "void ez::Drive::drive_imu_reset (double new_heading = \fR0\fP)"
Resets the current imu value\&. Defaults to 0, recommended to run at the start of your autonomous routine\&.

.PP
\fBParameters\fP
.RS 4
\fInew_heading\fP new heading value 
.RE
.PP

.SS "double ez::Drive::drive_imu_scaler_get ()"
Returns the current imu scaling factor\&. 
.SS "void ez::Drive::drive_imu_scaler_set (double scaler)"
Sets a new imu scaling factor\&.

.PP
This value is multiplied by the imu to change its output\&.

.PP
\fBParameters\fP
.RS 4
\fIscaler\fP factor to scale the imu by 
.RE
.PP

.SS "double ez::Drive::drive_mA_left ()"
The watts of the left motor\&. 
.SS "double ez::Drive::drive_mA_right ()"
The watts of the right motor\&. 
.SS "e_mode ez::Drive::drive_mode_get ()"
Returns current mode of drive\&. 
.SS "void ez::Drive::drive_mode_set (e_mode p_mode, bool stop_drive = \fRtrue\fP)"
Sets current mode of drive\&.

.PP
\fBParameters\fP
.RS 4
\fIp_mode\fP the new drive mode 
.br
\fIstop_drive\fP if the drive will stop when p_mode is DISABLED 
.RE
.PP

.SS "double ez::Drive::drive_ratio_get ()"
Returns the ratio of the drive\&. 
.SS "void ez::Drive::drive_ratio_set (double ratio)"
Set the ratio of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIratio\fP ratio of the gears 
.RE
.PP

.SS "double ez::Drive::drive_rpm_get ()"
Returns the current cartridge / wheel rpm\&. 
.SS "void ez::Drive::drive_rpm_set (double rpm)"
Set the cartridge/wheel rpm of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIrpm\fP rpm of the cartridge or wheel 
.RE
.PP

.SS "double ez::Drive::drive_sensor_left ()"
The position of the left sensor in inches\&.

.PP
If you have two parallel tracking wheels, this will return tracking wheel position\&. Otherwise this returns motor position\&. 
.SS "int ez::Drive::drive_sensor_left_raw ()"
The position of the left sensor\&.

.PP
If you have two parallel tracking wheels, this will return tracking wheel position\&. Otherwise this returns motor position\&. 
.SS "void ez::Drive::drive_sensor_reset ()"
Reset all the chassis motors and tracking wheels, recommended to run at the start of your autonomous routine\&. 
.SS "double ez::Drive::drive_sensor_right ()"
The position of the right sensor in inches\&.

.PP
If you have two parallel tracking wheels, this will return tracking wheel position\&. Otherwise this returns motor position\&. 
.SS "int ez::Drive::drive_sensor_right_raw ()"
The position of the right sensor\&.

.PP
If you have two parallel tracking wheels, this will return tracking wheel position\&. Otherwise this returns motor position\&. 
.SS "void ez::Drive::drive_set (int left, int right)"
Sets the chassis to voltage\&.

.PP
Disables \fBPID\fP when called\&.

.PP
\fBParameters\fP
.RS 4
\fIleft\fP voltage for left side, -127 to 127 
.br
\fIright\fP voltage for right side, -127 to 127 
.RE
.PP

.SS "double ez::Drive::drive_tick_per_inch ()"
Returns current tick_per_inch\&. 
.SS "int ez::Drive::drive_velocity_left ()"
The velocity of the left motor\&. 
.SS "int ez::Drive::drive_velocity_right ()"
The velocity of the right motor\&. 
.SS "double ez::Drive::drive_width_get ()"
Returns the width of the drive 
.SS "void ez::Drive::drive_width_set (double input)"
Sets the width of the drive\&.

.PP
This is used for tracking\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP a unit in inches, from center of the wheel to center of the wheel 
.RE
.PP

.SS "void ez::Drive::drive_width_set (okapi::QLength p_input)"
Sets the width of the drive\&.

.PP
This is used for tracking\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP an okapi unit, from center of the wheel to center of the wheel 
.RE
.PP

.SS "void ez::Drive::ez_tracking_task ()"
Tasks for tracking\&. 
.SS "void ez::Drive::initialize ()"
Calibrates imu and initializes sd card to curve\&. 
.SS "double ez::Drive::odom_boomerang_distance_get ()"
Returns how far away the carrot point can be from target\&. 
.SS "void ez::Drive::odom_boomerang_distance_set (double distance)"
Sets how far away the carrot point can be from the target point\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP distance in inches 
.RE
.PP

.SS "void ez::Drive::odom_boomerang_distance_set (okapi::QLength p_distance)"
Sets how far away the carrot point can be from the target point\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP distance as an okapi unit 
.RE
.PP

.SS "double ez::Drive::odom_boomerang_dlead_get ()"
Returns the current dlead\&. 
.SS "void ez::Drive::odom_boomerang_dlead_set (double input)"
Sets a new dlead\&.

.PP
Dlead is a proportional value of how much to make the robot curve during boomerang motions\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP a value between 0 and 1 
.RE
.PP

.SS "void ez::Drive::odom_enable (bool input)"
Enables / disables tracking\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP true enables tracking, false disables tracking 
.RE
.PP

.SS "bool ez::Drive::odom_enabled ()"
Returns whether the bot is tracking with odometry\&.

.PP
True means tracking is enabled, false means tracking is disabled\&. 
.SS "double ez::Drive::odom_look_ahead_get ()"
Returns how far away the robot looks in the path during pure pursuits\&. 
.SS "void ez::Drive::odom_look_ahead_set (double distance)"
Sets how far away the robot looks in the path during pure pursuits\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP how long the "carrot on a stick" is, in inches 
.RE
.PP

.SS "void ez::Drive::odom_look_ahead_set (okapi::QLength p_distance)"
Sets how far away the robot looks in the path during pure pursuits\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP how long the "carrot on a stick" is, in okapi units 
.RE
.PP

.SS "void ez::Drive::odom_path_print ()"
Prints the current path the robot is following\&. 
.SS "std::vector< double > ez::Drive::odom_path_smooth_constants_get ()"
Returns the constants for smoothing out a path\&.

.PP
In order of:
.IP "\(bu" 2
weight_smooth
.IP "\(bu" 2
weight_data
.IP "\(bu" 2
tolerance 
.PP

.SS "void ez::Drive::odom_path_smooth_constants_set (double weight_smooth, double weight_data, double tolerance)"
Sets the constants for smoothing out a path\&.

.PP
Path smoothing based on https://medium.com/@jaems33/understanding-robot-motion-path-smoothing-5970c8363bc4

.PP
\fBParameters\fP
.RS 4
\fIweight_smooth\fP how much weight to update the data 
.br
\fIweight_data\fP how much weight to smooth the coordinates 
.br
\fItolerance\fP how much change per iteration is necessary to keep iterating 
.RE
.PP

.SS "double ez::Drive::odom_path_spacing_get ()"
Returns the spacing between points when points get injected into the path\&. 
.SS "void ez::Drive::odom_path_spacing_set (double spacing)"
Sets the spacing between points when points get injected into the path\&.

.PP
\fBParameters\fP
.RS 4
\fIspacing\fP a small number in inches 
.RE
.PP

.SS "void ez::Drive::odom_path_spacing_set (okapi::QLength p_spacing)"
Sets the spacing between points when points get injected into the path\&.

.PP
\fBParameters\fP
.RS 4
\fIspacing\fP a small number in okapi units 
.RE
.PP

.SS "\fBpose\fP ez::Drive::odom_pose_get ()"
Returns the current pose of the robot\&. 
.SS "void ez::Drive::odom_pose_set (\fBpose\fP itarget)"
Sets the current pose of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIitarget\fP {x, y, t} units in inches and degrees 
.RE
.PP

.SS "void ez::Drive::odom_pose_set (\fBunited_pose\fP itarget)"
Sets the current pose of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIitarget\fP {x, y, t} as an okapi unit 
.RE
.PP

.SS "void ez::Drive::odom_reset ()"
Resets xyt to 0\&. 
.SS "bool ez::Drive::odom_theta_direction_get ()"
Checks if the rotation axis is flipped\&.

.PP
True means counterclockwise is positive, false means clockwise is positive\&. 
.SS "void ez::Drive::odom_theta_flip (bool flip = \fRtrue\fP)"
Flips the rotation axis\&.

.PP
\fBParameters\fP
.RS 4
\fIflip\fP true means counterclockwise is positive, false means clockwise is positive 
.RE
.PP

.SS "double ez::Drive::odom_theta_get ()"
Returns the current Theta of the robot in degrees\&. 
.SS "void ez::Drive::odom_theta_set (double a)"
Sets the current angle of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIa\fP new angle in degrees 
.RE
.PP

.SS "void ez::Drive::odom_theta_set (okapi::QAngle p_a)"
Sets the current Theta of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIp_a\fP new angle as an okapi unit 
.RE
.PP

.SS "void ez::Drive::odom_tracker_back_set (\fBtracking_wheel\fP * input)"
Sets the perpendicular back tracking wheel for odometry\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP an \fBez::tracking_wheel\fP 
.RE
.PP

.SS "void ez::Drive::odom_tracker_front_set (\fBtracking_wheel\fP * input)"
Sets the perpendicular front tracking wheel for odometry\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP an \fBez::tracking_wheel\fP 
.RE
.PP

.SS "void ez::Drive::odom_tracker_left_set (\fBtracking_wheel\fP * input)"
Sets the parallel left tracking wheel for odometry\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP an \fBez::tracking_wheel\fP 
.RE
.PP

.SS "void ez::Drive::odom_tracker_right_set (\fBtracking_wheel\fP * input)"
Sets the parallel right tracking wheel for odometry\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP an \fBez::tracking_wheel\fP 
.RE
.PP

.SS "double ez::Drive::odom_turn_bias_get ()"
Returns the proportion of how prioritized turning is during odometry motions\&. 
.SS "void ez::Drive::odom_turn_bias_set (double bias)"
A proportion of how prioritized turning is during odometry motions\&.

.PP
Turning is prioritized so the robot "applies brakes" while turning\&. Lower number means more braking\&.

.PP
\fBParameters\fP
.RS 4
\fIbias\fP a number between 0 and 1 
.RE
.PP

.SS "bool ez::Drive::odom_x_direction_get ()"
Checks if X axis is flipped\&.

.PP
True means left is positive X, false means right is positive X\&. 
.SS "void ez::Drive::odom_x_flip (bool flip = \fRtrue\fP)"
Flips the X axis\&.

.PP
\fBParameters\fP
.RS 4
\fIflip\fP true means left is positive x, false means right is positive x 
.RE
.PP

.SS "double ez::Drive::odom_x_get ()"
Returns the current X coordinate of the robot in inches\&. 
.SS "void ez::Drive::odom_x_set (double x)"
Sets the current X coordinate of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIx\fP new x coordinate in inches 
.RE
.PP

.SS "void ez::Drive::odom_x_set (okapi::QLength p_x)"
Sets the current X coordinate of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIp_x\fP new x coordinate as an okapi unit 
.RE
.PP

.SS "void ez::Drive::odom_xy_set (double x, double y)"
Sets the current X and Y coordinate for the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIx\fP new x value, in inches 
.br
\fIy\fP new y value, in inches 
.RE
.PP

.SS "void ez::Drive::odom_xy_set (okapi::QLength p_x, okapi::QLength p_y)"
Sets the current X and Y coordinate for the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIp_x\fP new x value, okapi unit 
.br
\fIp_y\fP new y value, okapi unit 
.RE
.PP

.SS "void ez::Drive::odom_xyt_set (double x, double y, double t)"
Sets the current X, Y, and Theta values for the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIx\fP new x value, in inches 
.br
\fIy\fP new y value, in inches 
.br
\fIt\fP new theta value, in degrees 
.RE
.PP

.SS "void ez::Drive::odom_xyt_set (okapi::QLength p_x, okapi::QLength p_y, okapi::QAngle p_t)"
Sets the current X, Y, and Theta values for the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIp_x\fP new x value, okapi unit 
.br
\fIp_y\fP new y value, okapi unit 
.br
\fIp_t\fP new theta value, okapi unit 
.RE
.PP

.SS "bool ez::Drive::odom_y_direction_get ()"
Checks if Y axis is flipped\&.

.PP
True means down is positive Y, false means up is positive Y\&. 
.SS "void ez::Drive::odom_y_flip (bool flip = \fRtrue\fP)"
Flips the Y axis\&.

.PP
\fBParameters\fP
.RS 4
\fIflip\fP true means down is positive y, false means up is positive y 
.RE
.PP

.SS "double ez::Drive::odom_y_get ()"
Returns the current Y coordinate of the robot in inches\&. 
.SS "void ez::Drive::odom_y_set (double y)"
Sets the current Y coordinate of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIy\fP new y coordinate in inches 
.RE
.PP

.SS "void ez::Drive::odom_y_set (okapi::QLength p_y)"
Sets the current Y coordinate of the robot\&.

.PP
\fBParameters\fP
.RS 4
\fIp_y\fP new y coordinate as an okapi unit 
.RE
.PP

.SS "void ez::Drive::opcontrol_arcade_flipped (e_type stick_type)"
Sets the chassis to controller joysticks using flipped arcade control, where right stick is fwd/rev\&. Run in usercontrol\&.

.PP
This passes the controller through the curve functions, but is disabled by default\&. Use \fBopcontrol_curve_buttons_toggle()\fP to enable it\&.

.PP
\fBParameters\fP
.RS 4
\fIstick_type\fP ez::SINGLE or ez::SPLIT control 
.RE
.PP

.SS "void ez::Drive::opcontrol_arcade_scaling (bool enable)"
Toggles vector scaling for arcade control\&. True enables, false disables\&.

.PP
\fBParameters\fP
.RS 4
\fIbool\fP true enables, false disables 
.RE
.PP

.SS "bool ez::Drive::opcontrol_arcade_scaling_enabled ()"
Returns if vector scaling for arcade control is enabled\&. True enables, false disables\&. 
.SS "void ez::Drive::opcontrol_arcade_standard (e_type stick_type)"
Sets the chassis to controller joysticks using standard arcade control, where left stick is fwd/rev\&. Run in usercontrol\&.

.PP
This passes the controller through the curve functions, but is disabled by default\&. Use \fBopcontrol_curve_buttons_toggle()\fP to enable it\&.

.PP
\fBParameters\fP
.RS 4
\fIstick_type\fP ez::SINGLE or ez::SPLIT control 
.RE
.PP

.SS "void ez::Drive::opcontrol_curve_buttons_iterate ()"
Iterates modifying controller curves with the controller\&. 
.SS "std::vector< pros::controller_digital_e_t > ez::Drive::opcontrol_curve_buttons_left_get ()"
Returns a vector of pros controller buttons user for the left joystick curve, in {decrease, increase} 
.SS "void ez::Drive::opcontrol_curve_buttons_left_set (pros::controller_digital_e_t decrease, pros::controller_digital_e_t increase)"
Sets buttons for modifying the left joystick curve\&.

.PP
\fBParameters\fP
.RS 4
\fIdecrease\fP a pros button enumerator 
.br
\fIincrease\fP a pros button enumerator 
.RE
.PP

.SS "std::vector< pros::controller_digital_e_t > ez::Drive::opcontrol_curve_buttons_right_get ()"
Returns a vector of pros controller buttons user for the right joystick curve, in {decrease, increase} 
.SS "void ez::Drive::opcontrol_curve_buttons_right_set (pros::controller_digital_e_t decrease, pros::controller_digital_e_t increase)"
Sets buttons for modifying the right joystick curve\&.

.PP
\fBParameters\fP
.RS 4
\fIdecrease\fP a pros button enumerator 
.br
\fIincrease\fP a pros button enumerator 
.RE
.PP

.SS "void ez::Drive::opcontrol_curve_buttons_toggle (bool toggle)"
Enables/disables modifying the joystick input curves with the controller\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP true enables, false disables 
.RE
.PP

.SS "bool ez::Drive::opcontrol_curve_buttons_toggle_get ()"
Gets the current state of the toggle\&. Enables/disables modifying the joystick input curves with the controller\&.

.PP
True enabled, false disabled\&. 
.SS "std::vector< double > ez::Drive::opcontrol_curve_default_get ()"
Gets the default joystick curves, in {left, right} 
.SS "void ez::Drive::opcontrol_curve_default_set (double left, double right = \fR0\fP)"
Sets the default joystick curves\&.

.PP
\fBParameters\fP
.RS 4
\fIleft\fP left default curve 
.br
\fIright\fP right default curve 
.RE
.PP

.SS "double ez::Drive::opcontrol_curve_left (double x)"
Outputs a curve from 5225A In the Zone\&.

.PP
This gives more control over the robot at lower speeds\&.

.PP
\fBParameters\fP
.RS 4
\fIx\fP joystick input 
.RE
.PP

.SS "double ez::Drive::opcontrol_curve_right (double x)"
Outputs a curve from 5225A In the Zone\&.

.PP
This gives more control over the robot at lower speeds\&.

.PP
\fBParameters\fP
.RS 4
\fIx\fP joystick input 
.RE
.PP

.SS "void ez::Drive::opcontrol_curve_sd_initialize ()"
Initializes left and right curves with the SD card, recommended to run in \fBinitialize()\fP\&. 
.SS "\fBPID::Constants\fP ez::Drive::opcontrol_drive_activebrake_constants_get ()"
Returns all \fBPID\fP constants for active brake\&. 
.SS "double ez::Drive::opcontrol_drive_activebrake_get ()"
Returns kP for active brake\&. 
.SS "void ez::Drive::opcontrol_drive_activebrake_set (double kp, double ki = \fR0\&.0\fP, double kd = \fR0\&.0\fP, double start_i = \fR0\&.0\fP)"
Runs a \fBPID\fP loop on the drive when the joysticks are released\&.

.PP
\fBParameters\fP
.RS 4
\fIkp\fP proportional term 
.br
\fIki\fP integral term 
.br
\fIkd\fP derivative term 
.br
\fIstart_i\fP error threshold to start integral 
.RE
.PP

.SS "bool ez::Drive::opcontrol_drive_reverse_get ()"
Gets current state of the toggle\&.

.PP
Reversal for drivetrain in opcontrol that flips the left and right side and the direction of the drive\&. 
.SS "void ez::Drive::opcontrol_drive_reverse_set (bool toggle)"
Reversal for drivetrain in opcontrol that flips the left and right side and the direction of the drive\&.

.PP
\fBParameters\fP
.RS 4
\fItoggle\fP true if you want your drivetrain reversed and false if you do not 
.RE
.PP

.SS "void ez::Drive::opcontrol_drive_sensors_reset ()"
Resets drive sensors at the start of opcontrol\&. 
.SS "void ez::Drive::opcontrol_joystick_practicemode_toggle (bool toggle)"
Practice mode for driver practice that shuts off the drive if you go max speed\&.

.PP
\fBParameters\fP
.RS 4
\fItoggle\fP true enables, false disables 
.RE
.PP

.SS "bool ez::Drive::opcontrol_joystick_practicemode_toggle_get ()"
Gets current state of the toggle\&.

.PP
True is enabled, false is disabled\&. 
.SS "int ez::Drive::opcontrol_joystick_threshold_get ()"
Gets the threshold for the joystick\&. 
.SS "void ez::Drive::opcontrol_joystick_threshold_iterate (int l_stick, int r_stick)"
Sets minimum value distance constants\&.

.PP
\fBParameters\fP
.RS 4
\fIl_stick\fP input for left joystick 
.br
\fIr_stick\fP input for right joystick 
.RE
.PP

.SS "void ez::Drive::opcontrol_joystick_threshold_set (int threshold)"
Sets a new threshold for the joystick\&.

.PP
The joysticks wil not return a value if they are within this\&.

.PP
\fBParameters\fP
.RS 4
\fIthreshold\fP new threshold 
.RE
.PP

.SS "int ez::Drive::opcontrol_speed_max_get ()"
Returns the max speed for user control\&. 
.SS "void ez::Drive::opcontrol_speed_max_set (int speed)"
Sets the max speed for user control\&.

.PP
\fBParameters\fP
.RS 4
\fIint\fP the speed limit 
.RE
.PP

.SS "void ez::Drive::opcontrol_tank ()"
Sets the chassis to controller joysticks using tank control\&. Run in usercontrol\&.

.PP
This passes the controller through the curve functions, but is disabled by default\&. Use \fBopcontrol_curve_buttons_toggle()\fP to enable it\&. 
.SS "e_angle_behavior ez::Drive::pid_angle_behavior_bias_get ()"
Returns the behavior when a turn is within its tolerance, you can have it bias left or right\&. 
.SS "void ez::Drive::pid_angle_behavior_bias_set (e_angle_behavior behavior)"
When a turn is within its tolerance, you can have it bias left or right\&.

.PP
\fBParameters\fP
.RS 4
\fIbehavior\fP ez::left or ez::right 
.RE
.PP

.SS "void ez::Drive::pid_angle_behavior_set (e_angle_behavior behavior)"
Sets the default behavior for turns in odom, swinging, and turning\&.

.PP
\fBParameters\fP
.RS 4
\fIbehavior\fP ez::shortest, ez::longest, ez::left, ez::right, ez::raw 
.RE
.PP

.SS "double ez::Drive::pid_angle_behavior_tolerance_get ()"
Returns the wiggle room in shortest vs longest, so a 180\&.1 and 179\&.9 degree turns have consistent behavior\&. 
.SS "void ez::Drive::pid_angle_behavior_tolerance_set (double tolerance)"
Gives some wiggle room in shortest vs longest, so a 180\&.1 and 179\&.9 degree turns have consistent behavior\&.

.PP
\fBParameters\fP
.RS 4
\fIp_tolerance\fP angle wiggle room, in degrees 
.RE
.PP

.SS "void ez::Drive::pid_angle_behavior_tolerance_set (okapi::QAngle p_tolerance)"
Gives some wiggle room in shortest vs longest, so a 180\&.1 and 179\&.9 degree turns have consistent behavior\&.

.PP
\fBParameters\fP
.RS 4
\fIp_tolerance\fP angle wiggle room, an okapi unit 
.RE
.PP

.SS "double ez::Drive::pid_drive_chain_backward_constant_get ()"
Returns the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion for driving backward\&. 
.SS "void ez::Drive::pid_drive_chain_backward_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets backward driving constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP distance in inches 
.RE
.PP

.SS "void ez::Drive::pid_drive_chain_backward_constant_set (okapi::QLength input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets backward driving constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi length unit 
.RE
.PP

.SS "void ez::Drive::pid_drive_chain_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This sets forward and backwards driving constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP distance in inches 
.RE
.PP

.SS "void ez::Drive::pid_drive_chain_constant_set (okapi::QLength input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This sets forward and backwards driving constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi length unit 
.RE
.PP

.SS "double ez::Drive::pid_drive_chain_forward_constant_get ()"
Returns the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion for driving forward\&. 
.SS "void ez::Drive::pid_drive_chain_forward_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets forward driving constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP distance in inches 
.RE
.PP

.SS "void ez::Drive::pid_drive_chain_forward_constant_set (okapi::QLength input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets forward driving constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi length unit 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_drive_constants_backward_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&. 
.SS "void ez::Drive::pid_drive_constants_backward_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the backwards pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_drive_constants_forward_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&. 
.SS "void ez::Drive::pid_drive_constants_forward_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the forward pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_drive_constants_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&.

.PP
Returns -1 if fwd and rev constants aren't the same! 
.SS "void ez::Drive::pid_drive_constants_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the drive pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "void ez::Drive::pid_drive_exit_condition_set (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for drive exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, in ms 
.br
\fIp_small_error\fP small timer will start when error is within this, in inches 
.br
\fIp_big_exit_time\fP time to exit when within big_error, in ms 
.br
\fIp_big_error\fP big timer will start when error is within this, in inches 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, in ms 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, in ms 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_drive_exit_condition_set (okapi::QTime p_small_exit_time, okapi::QLength p_small_error, okapi::QTime p_big_exit_time, okapi::QLength p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for drive exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, okapi unit 
.br
\fIp_small_error\fP small timer will start when error is within this, okapi unit 
.br
\fIp_big_exit_time\fP time to exit when within big_error, okapi unit 
.br
\fIp_big_error\fP big timer will start when error is within this, okapi unit 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, okapi unit 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, okapi unit 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_drive_set (double target, int speed)"
Sets the robot to move forward using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value in inches 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_drive_set (double target, int speed, bool slew_on, bool toggle_heading = \fRtrue\fP)"
Sets the robot to move forward using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value in inches 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.br
\fItoggle_heading\fP toggle for heading correction\&. true enables, false disables 
.RE
.PP

.SS "void ez::Drive::pid_drive_set (okapi::QLength p_target, int speed)"
Sets the robot to move forward using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target okapi unit 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_drive_set (okapi::QLength p_target, int speed, bool slew_on, bool toggle_heading = \fRtrue\fP)"
Sets the robot to move forward using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target okapi unit 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.br
\fItoggle_heading\fP toggle for heading correction\&. true enables, false disables 
.RE
.PP

.SS "void ez::Drive::pid_drive_toggle (bool toggle)"
Toggles set drive in autonomous\&.

.PP
\fBParameters\fP
.RS 4
\fItoggle\fP true enables, false disables 
.RE
.PP

.SS "bool ez::Drive::pid_drive_toggle_get ()"
Gets the current state of the toggle\&.

.PP
This toggles set drive in autonomous\&.

.PP
True enabled, false disabled\&. 
.SS "\fBPID::Constants\fP ez::Drive::pid_heading_constants_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&. 
.SS "void ez::Drive::pid_heading_constants_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the heading pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "void ez::Drive::pid_odom_angular_constants_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the odom angular pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "e_angle_behavior ez::Drive::pid_odom_behavior_get ()"
Returns the turn behavior for odom turns\&. 
.SS "void ez::Drive::pid_odom_behavior_set (e_angle_behavior behavior)"
Sets the default behavior for turns in odom turning movements\&.

.PP
\fBParameters\fP
.RS 4
\fIbehavior\fP ez::shortest, ez::longest, ez::left, ez::right, ez::raw 
.RE
.PP

.SS "void ez::Drive::pid_odom_boomerang_constants_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the odom boomerang pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "void ez::Drive::pid_odom_boomerang_set (\fBodom\fP imovement)"
Takes in an odom movement to go to a single point using boomerang\&. If an angle is set, this will run boomerang\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement 
.RE
.PP

.SS "void ez::Drive::pid_odom_boomerang_set (\fBodom\fP imovement, bool slew_on)"
Takes in an odom movement to go to a single point using boomerang\&. If an angle is set, this will run boomerang\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_boomerang_set (\fBunited_odom\fP p_imovement)"
Takes in an odom movement to go to a single point using boomerang\&. If an angle is set, this will run boomerang\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_boomerang_set (\fBunited_odom\fP p_imovement, bool slew_on)"
Takes in an odom movement to go to a single point using boomerang\&. If an angle is set, this will run boomerang\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_drive_exit_condition_set (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for odom driving exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, in ms 
.br
\fIp_small_error\fP small timer will start when error is within this, in inches 
.br
\fIp_big_exit_time\fP time to exit when within big_error, in ms 
.br
\fIp_big_error\fP big timer will start when error is within this, in inches 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, in ms 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, in ms 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_odom_drive_exit_condition_set (okapi::QTime p_small_exit_time, okapi::QLength p_small_error, okapi::QTime p_big_exit_time, okapi::QLength p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for odom driving exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, okapi unit 
.br
\fIp_small_error\fP small timer will start when error is within this, okapi unit 
.br
\fIp_big_exit_time\fP time to exit when within big_error, okapi unit 
.br
\fIp_big_error\fP big timer will start when error is within this, okapi unit 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, okapi unit 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, okapi unit 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_odom_injected_pp_set (std::vector< \fBodom\fP > imovements)"
Takes in odom movements to go through multiple points, will inject into the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.RE
.PP

.SS "void ez::Drive::pid_odom_injected_pp_set (std::vector< \fBodom\fP > imovements, bool slew_on)"
Takes in odom movements to go through multiple points, will inject into the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_injected_pp_set (std::vector< \fBunited_odom\fP > p_imovements)"
Takes in odom movements to go through multiple points, will inject into the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_injected_pp_set (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
Takes in odom movements to go through multiple points, will inject into the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_pp_set (std::vector< \fBodom\fP > imovements)"
Takes in odom movements to go through multiple points\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.RE
.PP

.SS "void ez::Drive::pid_odom_pp_set (std::vector< \fBodom\fP > imovements, bool slew_on)"
Takes in odom movements to go through multiple points\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_pp_set (std::vector< \fBunited_odom\fP > p_imovements)"
Takes in odom movements to go through multiple points\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_pp_set (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
Takes in odom movements to go through multiple points\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_ptp_set (\fBodom\fP imovement)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement 
.RE
.PP

.SS "void ez::Drive::pid_odom_ptp_set (\fBodom\fP imovement, bool slew_on)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_ptp_set (\fBunited_odom\fP p_imovement)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_ptp_set (\fBunited_odom\fP p_imovement, bool slew_on)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (double target, int speed)"
Sets the robot to move forward using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
This function is actually odom\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value as a double, unit is inches 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (double target, int speed, bool slew_on)"
Sets the robot to move forward using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
This function is actually odom

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value as a double, unit is inches 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (\fBodom\fP imovement)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (\fBodom\fP imovement, bool slew_on)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (okapi::QLength p_target, int speed)"
Sets the robot to move forward using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
This function is actually odom

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value in inches 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (okapi::QLength p_target, int speed, bool slew_on)"
Sets the robot to move forward using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
This function is actually odom

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value in inches 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.br
\fItoggle_heading\fP toggle for heading correction\&. true enables, false disables 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (std::vector< \fBodom\fP > imovements)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (std::vector< \fBodom\fP > imovements, bool slew_on)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (std::vector< \fBunited_odom\fP > p_imovements)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (\fBunited_odom\fP p_imovement)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_set (\fBunited_odom\fP p_imovement, bool slew_on)"
Takes in an odom movement to go to a single point\&. If an angle is set, this will run boomerang\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovement\fP {{x, y, t}, fwd/rev, 1-127} an odom movement\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_smooth_pp_set (std::vector< \fBodom\fP > imovements)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.RE
.PP

.SS "void ez::Drive::pid_odom_smooth_pp_set (std::vector< \fBodom\fP > imovements, bool slew_on)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_smooth_pp_set (std::vector< \fBunited_odom\fP > p_imovements)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.RE
.PP

.SS "void ez::Drive::pid_odom_smooth_pp_set (std::vector< \fBunited_odom\fP > p_imovements, bool slew_on)"
Takes in odom movements to go through multiple points, will inject and smooth the path\&. If an angle is set, this will run boomerang for that point\&. Uses slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIimovements\fP {{{x, y, t}, fwd/rev, 1-127}, {{x, y, t}, fwd/rev, 1-127}} odom movements\&. values are united here with okapi units 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_odom_turn_exit_condition_set (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for odom turning exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, in ms 
.br
\fIp_small_error\fP small timer will start when error is within this, in degrees 
.br
\fIp_big_exit_time\fP time to exit when within big_error, in ms 
.br
\fIp_big_error\fP big timer will start when error is within this, in degrees 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, in ms 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, in ms 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_odom_turn_exit_condition_set (okapi::QTime p_small_exit_time, okapi::QAngle p_small_error, okapi::QTime p_big_exit_time, okapi::QAngle p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for odom turning exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, okapi unit 
.br
\fIp_small_error\fP small timer will start when error is within this, okapi unit 
.br
\fIp_big_exit_time\fP time to exit when within big_error, okapi unit 
.br
\fIp_big_error\fP big timer will start when error is within this, okapi unit 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, okapi unit 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, okapi unit 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_print_toggle (bool toggle)"
Toggles printing in autonomous\&.

.PP
\fBParameters\fP
.RS 4
\fItoggle\fP true enables, false disables 
.RE
.PP

.SS "bool ez::Drive::pid_print_toggle_get ()"
Gets the current state of the toggle\&.

.PP
This toggles printing in autonomous\&.

.PP
True enabled, false disabled\&. 
.SS "int ez::Drive::pid_speed_max_get ()"
Returns max speed of drive during autonomous\&. 
.SS "void ez::Drive::pid_speed_max_set (int speed)"
Changes max speed during a drive motion\&.

.PP
\fBParameters\fP
.RS 4
\fIspeed\fP new clipped speed, between 0 and 127 
.RE
.PP

.SS "e_angle_behavior ez::Drive::pid_swing_behavior_get ()"
Returns the turn behavior for swings\&. 
.SS "void ez::Drive::pid_swing_behavior_set (e_angle_behavior behavior)"
Sets the default behavior for turns in swinging movements\&.

.PP
\fBParameters\fP
.RS 4
\fIbehavior\fP ez::shortest, ez::longest, ez::left, ez::right, ez::raw 
.RE
.PP

.SS "double ez::Drive::pid_swing_chain_backward_constant_get ()"
Returns the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion for swinging backward\&. 
.SS "void ez::Drive::pid_swing_chain_backward_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets backwards swing constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP angle in degrees 
.RE
.PP

.SS "void ez::Drive::pid_swing_chain_backward_constant_set (okapi::QAngle input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets backward swing constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi angle unit 
.RE
.PP

.SS "void ez::Drive::pid_swing_chain_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This sets forward and backwards swing constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP angle in degrees 
.RE
.PP

.SS "void ez::Drive::pid_swing_chain_constant_set (okapi::QAngle input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This sets forward and backwards swing constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi angle unit 
.RE
.PP

.SS "double ez::Drive::pid_swing_chain_forward_constant_get ()"
Returns the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion for swinging forward\&. 
.SS "void ez::Drive::pid_swing_chain_forward_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets forward constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP angle in degrees 
.RE
.PP

.SS "void ez::Drive::pid_swing_chain_forward_constant_set (okapi::QAngle input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This only sets forward swing constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi angle unit 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_swing_constants_backward_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&. 
.SS "void ez::Drive::pid_swing_constants_backward_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the backward swing pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_swing_constants_forward_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&. 
.SS "void ez::Drive::pid_swing_constants_forward_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the forward swing pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_swing_constants_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&.

.PP
Returns -1 if fwd and rev constants aren't the same! 
.SS "void ez::Drive::pid_swing_constants_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the swing pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "void ez::Drive::pid_swing_exit_condition_set (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for swing exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, in ms 
.br
\fIp_small_error\fP small timer will start when error is within this, in degrees 
.br
\fIp_big_exit_time\fP time to exit when within big_error, in ms 
.br
\fIp_big_error\fP big timer will start when error is within this, in degrees 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, in ms 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, in ms 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_swing_exit_condition_set (okapi::QTime p_small_exit_time, okapi::QAngle p_small_error, okapi::QTime p_big_exit_time, okapi::QAngle p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for swing exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, okapi unit 
.br
\fIp_small_error\fP small timer will start when error is within this, okapi unit 
.br
\fIp_big_exit_time\fP time to exit when within big_error, okapi unit 
.br
\fIp_big_error\fP big timer will start when error is within this, okapi unit 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, okapi unit 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, okapi unit 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "int ez::Drive::pid_swing_min_get ()"
Returns minimum power for swings when kI and startI are enabled\&. 
.SS "void ez::Drive::pid_swing_min_set (int min)"
Sets minimum power for swings when kI and startI are enabled\&.

.PP
\fBParameters\fP
.RS 4
\fImin\fP new clipped speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, e_angle_behavior behavior)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, int opposite_speed)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, int opposite_speed, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_relative_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn only using the left or right side relative to current heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, e_angle_behavior behavior)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, int opposite_speed)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, int opposite_speed, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, double target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, bool slew_on)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior)"
Sets the robot to turn using only the left or right side relative to initial heading with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_swing_set (e_swing type, okapi::QAngle p_target, int speed, int opposite_speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn only using the left or right side relative to initial heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItype\fP L_SWING or R_SWING 
.br
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIopposite_speed\fP -127 to 127, max speed of the opposite side of the drive during the swing\&. this is used for arcs, and is defaulted to 0 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_targets_reset ()"
Resets all \fBPID\fP targets to 0\&. 
.SS "void ez::Drive::pid_tuner_disable ()"
Disables \fBPID\fP Tuner\&. 
.SS "void ez::Drive::pid_tuner_enable ()"
Enables \fBPID\fP Tuner\&. 
.SS "bool ez::Drive::pid_tuner_enabled ()"
Checks if \fBPID\fP Tuner is enabled\&.

.PP
True is enabled, false is disabled\&. 
.SS "void ez::Drive::pid_tuner_full_enable (bool enable)"
Enables the full \fBPID\fP tuner with unique fwd/rev constants\&.

.PP
\fBParameters\fP
.RS 4
\fIenable\fP true will enable the full \fBPID\fP tuner, false will use the simplified \fBPID\fP tuner 
.RE
.PP

.SS "bool ez::Drive::pid_tuner_full_enabled ()"
Returns if the full \fBPID\fP tuner with unique fwd/rev constants is enabled\&.

.PP
True means the full \fBPID\fP tuner is enabled, false means the simplified \fBPID\fP tuner is enabled\&. 
.SS "double ez::Drive::pid_tuner_increment_d_get ()"
Returns the value that \fBPID\fP Tuner increments D\&. 
.SS "void ez::Drive::pid_tuner_increment_d_set (double d)"
Sets the value that \fBPID\fP Tuner increments D\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP d will increase by this 
.RE
.PP

.SS "double ez::Drive::pid_tuner_increment_i_get ()"
Returns the value that \fBPID\fP Tuner increments I\&. 
.SS "void ez::Drive::pid_tuner_increment_i_set (double i)"
Sets the value that \fBPID\fP Tuner increments I\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP i will increase by this 
.RE
.PP

.SS "double ez::Drive::pid_tuner_increment_p_get ()"
Returns the value that \fBPID\fP Tuner increments P\&. 
.SS "void ez::Drive::pid_tuner_increment_p_set (double p)"
Sets the value that \fBPID\fP Tuner increments P\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP p will increase by this 
.RE
.PP

.SS "double ez::Drive::pid_tuner_increment_start_i_get ()"
Returns the value that \fBPID\fP Tuner increments Start I\&. 
.SS "void ez::Drive::pid_tuner_increment_start_i_set (double start_i)"
Sets the value that \fBPID\fP Tuner increments Start I\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP start i will increase by this 
.RE
.PP

.SS "void ez::Drive::pid_tuner_iterate ()"
Iterates through controller inputs to modify \fBPID\fP constants\&. 
.SS "bool ez::Drive::pid_tuner_print_brain_enabled ()"
Returns true if printing to brain is enabled\&. 
.SS "void ez::Drive::pid_tuner_print_brain_set (bool input)"
Toggle for printing the display of the \fBPID\fP Tuner to the brain\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP true prints to brain, false doesn't 
.RE
.PP

.SS "bool ez::Drive::pid_tuner_print_terminal_enabled ()"
Returns true if printing to terminal is enabled\&. 
.SS "void ez::Drive::pid_tuner_print_terminal_set (bool input)"
Toggle for printing the display of the \fBPID\fP Tuner to the terminal\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP true prints to terminal, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_tuner_toggle ()"
Toggles \fBPID\fP tuner between enabled and disabled\&. 
.SS "e_angle_behavior ez::Drive::pid_turn_behavior_get ()"
Returns the turn behavior for turns\&. 
.SS "void ez::Drive::pid_turn_behavior_set (e_angle_behavior behavior)"
Sets the default behavior for turns in turning movements\&.

.PP
\fBParameters\fP
.RS 4
\fIbehavior\fP ez::shortest, ez::longest, ez::left, ez::right, ez::raw 
.RE
.PP

.SS "double ez::Drive::pid_turn_chain_constant_get ()"
Returns the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion for turning\&. 
.SS "void ez::Drive::pid_turn_chain_constant_set (double input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This sets turning constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP angle in degrees 
.RE
.PP

.SS "void ez::Drive::pid_turn_chain_constant_set (okapi::QAngle input)"
Sets the amount that the \fBPID\fP will overshoot target by to maintain momentum into the next motion\&.

.PP
This sets turning constants\&.

.PP
\fBParameters\fP
.RS 4
\fIinput\fP okapi angle unit 
.RE
.PP

.SS "\fBPID::Constants\fP ez::Drive::pid_turn_constants_get ()"
Returns \fBPID\fP constants with \fBPID::Constants\fP\&. 
.SS "void ez::Drive::pid_turn_constants_set (double p, double i = \fR0\&.0\fP, double d = \fR0\&.0\fP, double p_start_i = \fR0\&.0\fP)"
Set the turn pid constants object\&.

.PP
\fBParameters\fP
.RS 4
\fIp\fP proportional term 
.br
\fIi\fP integral term 
.br
\fId\fP derivative term 
.br
\fIp_start_i\fP error threshold to start integral 
.RE
.PP

.SS "void ez::Drive::pid_turn_exit_condition_set (int p_small_exit_time, double p_small_error, int p_big_exit_time, double p_big_error, int p_velocity_exit_time, int p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for turn exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, in ms 
.br
\fIp_small_error\fP small timer will start when error is within this, in degrees 
.br
\fIp_big_exit_time\fP time to exit when within big_error, in ms 
.br
\fIp_big_error\fP big timer will start when error is within this, in degrees 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, in ms 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, in ms 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "void ez::Drive::pid_turn_exit_condition_set (okapi::QTime p_small_exit_time, okapi::QAngle p_small_error, okapi::QTime p_big_exit_time, okapi::QAngle p_big_error, okapi::QTime p_velocity_exit_time, okapi::QTime p_mA_timeout, bool use_imu = \fRtrue\fP)"
Set's constants for turn exit conditions\&.

.PP
\fBParameters\fP
.RS 4
\fIp_small_exit_time\fP time to exit when within smalL_error, okapi unit 
.br
\fIp_small_error\fP small timer will start when error is within this, okapi unit 
.br
\fIp_big_exit_time\fP time to exit when within big_error, okapi unit 
.br
\fIp_big_error\fP big timer will start when error is within this, okapi unit 
.br
\fIp_velocity_exit_time\fP velocity timer will start when velocity is 0, okapi unit 
.br
\fIp_mA_timeout\fP mA timer will start when the motors are pulling too much current, okapi unit 
.br
\fIuse_imu\fP true adds the imu for velocity calculation in conjunction with the main sensor, false doesn't 
.RE
.PP

.SS "int ez::Drive::pid_turn_min_get ()"
Returns minimum power for turns when kI and startI are enabled\&. 
.SS "void ez::Drive::pid_turn_min_set (int min)"
The minimum power for turns when kI and startI are enabled\&.

.PP
\fBParameters\fP
.RS 4
\fImin\fP new clipped speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (double target, int speed)"
Sets the robot to turn relative to current heading using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (double target, int speed, bool slew_on)"
Sets the robot to turn relative to current heading using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (double target, int speed, e_angle_behavior behavior)"
Sets the robot to turn relative to current heading using \fBPID\fP without okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (double target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn relative to current heading using \fBPID\fP without okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (okapi::QAngle p_target, int speed)"
Sets the robot to turn relative to current heading using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (okapi::QAngle p_target, int speed, bool slew_on)"
Sets the robot to turn relative to current heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
Sets the robot to turn relative to current heading using \fBPID\fP with okapi units, only using slew if globally enabled\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_turn_relative_set (okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn relative to current heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (double target, int speed)"
Sets the robot to turn relative to initial heading using \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (double target, int speed, bool slew_on)"
Sets the robot to turn relative to initial heading using \fBPID\fP, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (double target, int speed, e_angle_behavior behavior)"
Sets the robot to turn relative to initial heading using \fBPID\fP\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (double target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn relative to initial heading using \fBPID\fP, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP target value as a double, unit is degrees 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (okapi::QAngle p_target, int speed)"
Sets the robot to turn relative to initial heading using \fBPID\fP with okapi units\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (okapi::QAngle p_target, int speed, bool slew_on)"
Sets the robot to turn relative to initial heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (okapi::QAngle p_target, int speed, e_angle_behavior behavior)"
Sets the robot to turn relative to initial heading using \fBPID\fP with okapi units\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (okapi::QAngle p_target, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn relative to initial heading using \fBPID\fP with okapi units, using slew if enabled for this motion\&.

.PP
\fBParameters\fP
.RS 4
\fIp_target\fP target value in okapi angle units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBpose\fP itarget, drive_directions dir, int speed)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBpose\fP itarget, drive_directions dir, int speed, bool slew_on)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBpose\fP itarget, drive_directions dir, int speed, e_angle_behavior behavior)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBpose\fP itarget, drive_directions dir, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBunited_pose\fP p_itarget, drive_directions dir, int speed)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face\&. this uses okapi units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBunited_pose\fP p_itarget, drive_directions dir, int speed, bool slew_on)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face\&. this uses okapi units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBunited_pose\fP p_itarget, drive_directions dir, int speed, e_angle_behavior behavior)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face\&. this uses okapi units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.RE
.PP

.SS "void ez::Drive::pid_turn_set (\fBunited_pose\fP p_itarget, drive_directions dir, int speed, e_angle_behavior behavior, bool slew_on)"
Sets the robot to turn face a point using \fBPID\fP and odometry\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a target point to face\&. this uses okapi units 
.br
\fIspeed\fP 0 to 127, max speed during motion 
.br
\fIbehavior\fP changes what direction the robot will turn\&. can be left, right, shortest, longest, raw 
.br
\fIslew_on\fP ramp up from a lower speed to your target speed 
.RE
.PP

.SS "void ez::Drive::pid_wait ()"
Lock the code in a while loop until the robot has settled\&. 
.SS "void ez::Drive::pid_wait_quick ()"
Lock the code in a while loop until the robot has settled\&.

.PP
Wrapper for pid_wait_until(target), target is your previously input target\&. 
.SS "void ez::Drive::pid_wait_quick_chain ()"
Lock the code in a while loop until the robot has settled\&.

.PP
This also adds distance to target, and then exits with pid_wait_quick\&.

.PP
This will exit the motion while carrying momentum into the next motion\&. 
.SS "void ez::Drive::pid_wait_until (double target)"
Lock the code in a while loop until this position has passed for driving without okapi units\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP for driving or turning, using a double\&. degrees for turns/swings, inches for driving 
.RE
.PP

.SS "void ez::Drive::pid_wait_until (okapi::QAngle target)"
Lock the code in a while loop until this position has passed for turning or swinging with okapi units\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP for turning, using okapi units 
.RE
.PP

.SS "void ez::Drive::pid_wait_until (okapi::QLength target)"
Lock the code in a while loop until this position has passed for driving with okapi units\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP for driving, using okapi units 
.RE
.PP

.SS "void ez::Drive::pid_wait_until (\fBpose\fP target)"
Lock the code in a while loop until this point has been passed\&.

.PP
Wrapper for pid_wait_until_point\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a pose for the robot to pass through before the while loop is released 
.RE
.PP

.SS "void ez::Drive::pid_wait_until (\fBunited_pose\fP target)"
Lock the code in a while loop until this point has been passed, with okapi units\&.

.PP
Wrapper for pid_wait_until_point\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} a pose with units for the robot to pass through before the while loop is released 
.RE
.PP

.SS "void ez::Drive::pid_wait_until_index (int index)"
Lock the code in a while loop until this point has been passed\&.

.PP
\fBParameters\fP
.RS 4
\fIindex\fP index of your input points, 0 is the first point in the index 
.RE
.PP

.SS "void ez::Drive::pid_wait_until_index_started (int index)"
Lock the code in a while loop until this point becomes the target\&.

.PP
\fBParameters\fP
.RS 4
\fIindex\fP index of your input points, 0 is the first point in the index 
.RE
.PP

.SS "void ez::Drive::pid_wait_until_point (\fBpose\fP target)"
Lock the code in a while loop until this point has been passed\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} pose for the robot to pass through before the while loop is released 
.RE
.PP

.SS "void ez::Drive::pid_wait_until_point (\fBunited_pose\fP target)"
Lock the code in a while loop until this point has been passed, with okapi units\&.

.PP
\fBParameters\fP
.RS 4
\fItarget\fP {x, y} pose with units for the robot to pass through before the while loop is released 
.RE
.PP

.SS "void ez::Drive::pto_add (std::vector< \fBpros::Motor\fP > pto_list)"
Adds motors to the pto list, removing them from the drive\&.

.PP
You cannot add the first index because it's used for autonomous\&.

.PP
\fBParameters\fP
.RS 4
\fIpto_list\fP list of motors to remove from the drive 
.RE
.PP

.SS "bool ez::Drive::pto_check (\fBpros::Motor\fP check_if_pto)"
Checks if the motor is currently in pto_list\&.

.PP
Returns true if it's already in pto_list\&.

.PP
\fBParameters\fP
.RS 4
\fIcheck_if_pto\fP motor to check 
.RE
.PP

.SS "void ez::Drive::pto_remove (std::vector< \fBpros::Motor\fP > pto_list)"
Removes motors from the pto list, adding them to the drive\&.

.PP
\fBParameters\fP
.RS 4
\fIpto_list\fP list of motors to add to the drive 
.RE
.PP

.SS "void ez::Drive::pto_toggle (std::vector< \fBpros::Motor\fP > pto_list, bool toggle)"
Adds/removes motors from drive\&.

.PP
You cannot add the first index because it's used for autonomous\&.

.PP
\fBParameters\fP
.RS 4
\fIpto_list\fP list of motors to add/remove from the drive 
.br
\fItoggle\fP list of motors to add/remove from the drive 
.RE
.PP

.SS "bool ez::Drive::slew_drive_backward_get ()"
Returns true if slew is enabled for all drive backward movements, false otherwise\&. 
.SS "void ez::Drive::slew_drive_backward_set (bool slew_on)"
Sets the default slew for drive backward motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "void ez::Drive::slew_drive_constants_backward_set (okapi::QLength distance, int min_speed)"
Sets constants for slew for driving backward\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi distance unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_drive_constants_forward_set (okapi::QLength distance, int min_speed)"
Sets constants for slew for driving forward\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi distance unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_drive_constants_set (okapi::QLength distance, int min_speed)"
Sets constants for slew for driving\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi distance unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "bool ez::Drive::slew_drive_forward_get ()"
Returns true if slew is enabled for all drive forward movements, false otherwise\&. 
.SS "void ez::Drive::slew_drive_forward_set (bool slew_on)"
Sets the default slew for drive forward motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "void ez::Drive::slew_drive_set (bool slew_on)"
Sets the default slew for drive forwards and backwards motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "void ez::Drive::slew_odom_reenable (bool reenable)"
Allows slew to reenable when the new input speed is larger than the current speed during pure pursuits\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "bool ez::Drive::slew_odom_reenabled ()"
Returns if slew will reenable when the new input speed is larger than the current speed during pure pursuits\&. 
.SS "bool ez::Drive::slew_swing_backward_get ()"
Returns true if slew is enabled for all swing backward motions, false otherwise\&. 
.SS "void ez::Drive::slew_swing_backward_set (bool slew_on)"
Sets the default slew for swing backward motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "void ez::Drive::slew_swing_constants_backward_set (okapi::QAngle distance, int min_speed)"
Sets constants for slew for swing backward movements\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi angle unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_swing_constants_backward_set (okapi::QLength distance, int min_speed)"
Sets constants for slew for backward swing movements\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi distance unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_swing_constants_forward_set (okapi::QAngle distance, int min_speed)"
Sets constants for slew for swing forward movements\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi angle unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_swing_constants_forward_set (okapi::QLength distance, int min_speed)"
Sets constants for slew for forward swing movements\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi distance unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_swing_constants_set (okapi::QAngle distance, int min_speed)"
Sets constants for slew for swing movements\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi angle unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "void ez::Drive::slew_swing_constants_set (okapi::QLength distance, int min_speed)"
Sets constants for slew for swing movements\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi distance unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "bool ez::Drive::slew_swing_forward_get ()"
Returns true if slew is enabled for all swing forward motions, false otherwise\&. 
.SS "void ez::Drive::slew_swing_forward_set (bool slew_on)"
Sets the default slew for swing forward motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "void ez::Drive::slew_swing_set (bool slew_on)"
Sets the default slew for swing forward and backward motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SS "void ez::Drive::slew_turn_constants_set (okapi::QAngle distance, int min_speed)"
Sets constants for slew for turns\&.

.PP
Slew ramps up the speed of the robot until the set distance is traveled\&.

.PP
\fBParameters\fP
.RS 4
\fIdistance\fP the distance the robot travels before reaching max speed, an okapi angle unit 
.br
\fImin_speed\fP the starting speed for the movement, 0 - 127 
.RE
.PP

.SS "bool ez::Drive::slew_turn_get ()"
Returns true if slew is enabled for all turn motions, false otherwise\&. 
.SS "void ez::Drive::slew_turn_set (bool slew_on)"
Sets the default slew for turn motions, can be overwritten in movement functions\&.

.PP
\fBParameters\fP
.RS 4
\fIslew_on\fP true enables, false disables 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "pros::motor_brake_mode_e_t ez::Drive::CURRENT_BRAKE = pros::E_MOTOR_BRAKE_COAST"
Global current brake mode\&. 
.SS "int ez::Drive::CURRENT_MA = 2500"
Global current mA\&. 
.SS "e_swing ez::Drive::current_swing"
Current swing type\&. 
.SS "\fBpros::Task\fP ez::Drive::ez_auto"
Tasks for autonomous\&. 
.SS "\fBPID\fP ez::Drive::headingPID"
\fBPID\fP objects\&. 
.SS "\fBpros::Imu\fP ez::Drive::imu"
Inertial sensor\&. 
.SS "bool ez::Drive::interfered = false"
Autonomous interference detection\&.

.PP
Returns true when interfered, and false when nothing happened\&. 
.SS "int ez::Drive::JOYSTICK_THRESHOLD"
Joysticks will return 0 when they are within this number\&.

.PP
Set with \fBopcontrol_joystick_threshold_set()\fP 
.SS "std::vector<\fBpros::Motor\fP> ez::Drive::left_motors"
Vector of pros motors for the left chassis\&. 
.SS "\fBpros::Rotation\fP ez::Drive::left_rotation"
Deprecated left rotation tracker\&. 
.SS "\fBpros::adi::Encoder\fP ez::Drive::left_tracker"
Deprecated left tracking wheel\&. 
.SS "e_mode ez::Drive::mode"
Current mode of the drive\&. 
.SS "\fBtracking_wheel\fP* ez::Drive::odom_tracker_back"
Back horizontal tracking wheel\&. 
.SS "\fBtracking_wheel\fP* ez::Drive::odom_tracker_front"
Front horizontal tracking wheel\&. 
.SS "\fBtracking_wheel\fP* ez::Drive::odom_tracker_left"
Left vertical tracking wheel\&. 
.SS "\fBtracking_wheel\fP* ez::Drive::odom_tracker_right"
Right vertical tracking wheel\&. 
.SS "std::vector<\fBconst_and_name\fP> ez::Drive::pid_tuner_full_pids"
\fBInitial value:\fP
.nf
.PP
.fi
Vector used for the full \fBPID\fP Tuner 
.SS "std::vector<\fBconst_and_name\fP> ez::Drive::pid_tuner_pids"
\fBInitial value:\fP
.nf
.PP
.fi
Vector used for a simplified \fBPID\fP Tuner 
.SS "std::vector<int> ez::Drive::pto_active"
Vector of pros motors that are disconnected from the drive\&. 
.SS "std::vector<\fBpros::Motor\fP> ez::Drive::right_motors"
Vector of pros motors for the right chassis\&. 
.SS "\fBpros::Rotation\fP ez::Drive::right_rotation"
Deprecated right rotation tracker\&. 
.SS "\fBpros::adi::Encoder\fP ez::Drive::right_tracker"
Deprecated right tracking wheel\&. 
.SS "\fBez::slew\fP ez::Drive::slew_left"
Slew objects\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
