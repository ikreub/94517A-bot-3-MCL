.TH "include/liblvgl/misc/lv_area.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/misc/lv_area.h
.SH SYNOPSIS
.br
.PP
\fR#include 'liblvgl/lv_conf_internal\&.h'\fP
.br
\fR#include <stdbool\&.h>\fP
.br
\fR#include <stdint\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBlv_point_t\fP"
.br
.ti -1c
.RI "struct \fBlv_area_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_LV_COORD_TYPE_SHIFT\fP   (13U)"
.br
.ti -1c
.RI "#define \fB_LV_COORD_TYPE_MASK\fP   (3 << _LV_COORD_TYPE_SHIFT)"
.br
.ti -1c
.RI "#define \fB_LV_COORD_TYPE\fP(x)"
.br
.ti -1c
.RI "#define \fB_LV_COORD_PLAIN\fP(x)"
.br
.ti -1c
.RI "#define \fB_LV_COORD_TYPE_PX\fP   (0 << _LV_COORD_TYPE_SHIFT)"
.br
.ti -1c
.RI "#define \fB_LV_COORD_TYPE_SPEC\fP   (1 << _LV_COORD_TYPE_SHIFT)"
.br
.ti -1c
.RI "#define \fB_LV_COORD_TYPE_PX_NEG\fP   (3 << _LV_COORD_TYPE_SHIFT)"
.br
.ti -1c
.RI "#define \fBLV_COORD_IS_PX\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_COORD_IS_SPEC\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_COORD_SET_SPEC\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_PCT\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_COORD_IS_PCT\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_COORD_GET_PCT\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_SIZE_CONTENT\fP   LV_COORD_SET_SPEC(2001)"
.br
.ti -1c
.RI "#define \fBLV_COORD_MAX\fP   ((1 << _LV_COORD_TYPE_SHIFT) \- 1)"
.br
.ti -1c
.RI "#define \fBLV_COORD_MIN\fP   (\-LV_COORD_MAX)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBlv_align_t\fP"
.br
.ti -1c
.RI "typedef uint8_t \fBlv_dir_t\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBLV_ALIGN_DEFAULT\fP = 0, \fBLV_ALIGN_TOP_LEFT\fP, \fBLV_ALIGN_TOP_MID\fP, \fBLV_ALIGN_TOP_RIGHT\fP, \fBLV_ALIGN_BOTTOM_LEFT\fP, \fBLV_ALIGN_BOTTOM_MID\fP, \fBLV_ALIGN_BOTTOM_RIGHT\fP, \fBLV_ALIGN_LEFT_MID\fP, \fBLV_ALIGN_RIGHT_MID\fP, \fBLV_ALIGN_CENTER\fP, \fBLV_ALIGN_OUT_TOP_LEFT\fP, \fBLV_ALIGN_OUT_TOP_MID\fP, \fBLV_ALIGN_OUT_TOP_RIGHT\fP, \fBLV_ALIGN_OUT_BOTTOM_LEFT\fP, \fBLV_ALIGN_OUT_BOTTOM_MID\fP, \fBLV_ALIGN_OUT_BOTTOM_RIGHT\fP, \fBLV_ALIGN_OUT_LEFT_TOP\fP, \fBLV_ALIGN_OUT_LEFT_MID\fP, \fBLV_ALIGN_OUT_LEFT_BOTTOM\fP, \fBLV_ALIGN_OUT_RIGHT_TOP\fP, \fBLV_ALIGN_OUT_RIGHT_MID\fP, \fBLV_ALIGN_OUT_RIGHT_BOTTOM\fP }"
.br
.ti -1c
.RI "enum { \fBLV_DIR_NONE\fP = 0x00, \fBLV_DIR_LEFT\fP = (1 << 0), \fBLV_DIR_RIGHT\fP = (1 << 1), \fBLV_DIR_TOP\fP = (1 << 2), \fBLV_DIR_BOTTOM\fP = (1 << 3), \fBLV_DIR_HOR\fP = LV_DIR_LEFT | LV_DIR_RIGHT, \fBLV_DIR_VER\fP = LV_DIR_TOP | LV_DIR_BOTTOM, \fBLV_DIR_ALL\fP = LV_DIR_HOR | LV_DIR_VER }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBlv_area_set\fP (\fBlv_area_t\fP *area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)"
.br
.ti -1c
.RI "void \fBlv_area_set_width\fP (\fBlv_area_t\fP *area_p, lv_coord_t w)"
.br
.ti -1c
.RI "void \fBlv_area_set_height\fP (\fBlv_area_t\fP *area_p, lv_coord_t h)"
.br
.ti -1c
.RI "void \fB_lv_area_set_pos\fP (\fBlv_area_t\fP *area_p, lv_coord_t x, lv_coord_t y)"
.br
.ti -1c
.RI "uint32_t \fBlv_area_get_size\fP (const \fBlv_area_t\fP *area_p)"
.br
.ti -1c
.RI "void \fBlv_area_increase\fP (\fBlv_area_t\fP *area, lv_coord_t w_extra, lv_coord_t h_extra)"
.br
.ti -1c
.RI "void \fBlv_area_move\fP (\fBlv_area_t\fP *area, lv_coord_t x_ofs, lv_coord_t y_ofs)"
.br
.ti -1c
.RI "bool \fB_lv_area_intersect\fP (\fBlv_area_t\fP *res_p, const \fBlv_area_t\fP *a1_p, const \fBlv_area_t\fP *a2_p)"
.br
.ti -1c
.RI "void \fB_lv_area_join\fP (\fBlv_area_t\fP *a_res_p, const \fBlv_area_t\fP *a1_p, const \fBlv_area_t\fP *a2_p)"
.br
.ti -1c
.RI "bool \fB_lv_area_is_point_on\fP (const \fBlv_area_t\fP *a_p, const \fBlv_point_t\fP *p_p, lv_coord_t radius)"
.br
.ti -1c
.RI "bool \fB_lv_area_is_on\fP (const \fBlv_area_t\fP *a1_p, const \fBlv_area_t\fP *a2_p)"
.br
.ti -1c
.RI "bool \fB_lv_area_is_in\fP (const \fBlv_area_t\fP *ain_p, const \fBlv_area_t\fP *aholder_p, lv_coord_t radius)"
.br
.ti -1c
.RI "bool \fB_lv_area_is_out\fP (const \fBlv_area_t\fP *aout_p, const \fBlv_area_t\fP *aholder_p, lv_coord_t radius)"
.br
.ti -1c
.RI "bool \fB_lv_area_is_equal\fP (const \fBlv_area_t\fP *a, const \fBlv_area_t\fP *b)"
.br
.ti -1c
.RI "void \fBlv_area_align\fP (const \fBlv_area_t\fP *base, \fBlv_area_t\fP *to_align, lv_align_t align, lv_coord_t ofs_x, lv_coord_t ofs_y)"
.br
.ti -1c
.RI "void \fBlv_point_transform\fP (\fBlv_point_t\fP *p, int32_t angle, int32_t zoom, const \fBlv_point_t\fP *pivot)"
.br
.ti -1c
.RI "\fBLV_EXPORT_CONST_INT\fP (LV_SIZE_CONTENT)"
.br
.ti -1c
.RI "\fBLV_EXPORT_CONST_INT\fP (LV_COORD_MAX)"
.br
.ti -1c
.RI "\fBLV_EXPORT_CONST_INT\fP (LV_COORD_MIN)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define _LV_COORD_PLAIN( x)"
\fBValue:\fP
.nf
((x) & ~_LV_COORD_TYPE_MASK) /*Remove type specifiers*/
.PP
.fi

.SS "#define _LV_COORD_TYPE( x)"
\fBValue:\fP
.nf
((x) & _LV_COORD_TYPE_MASK)  /*Extract type specifiers*/
.PP
.fi

.SS "#define LV_COORD_GET_PCT( x)"
\fBValue:\fP
.nf
(_LV_COORD_PLAIN(x) > 1000 ? 1000 \- _LV_COORD_PLAIN(x) : _LV_COORD_PLAIN(x))
.PP
.fi

.SS "#define LV_COORD_IS_PCT( x)"
\fBValue:\fP
.nf
((LV_COORD_IS_SPEC(x) && _LV_COORD_PLAIN(x) <= 2000) ? true : false)
.PP
.fi

.SS "#define LV_COORD_IS_PX( x)"
\fBValue:\fP
.nf
(_LV_COORD_TYPE(x) == _LV_COORD_TYPE_PX || \\
_LV_COORD_TYPE(x) == _LV_COORD_TYPE_PX_NEG ? true : false)
.PP
.fi

.SS "#define LV_COORD_IS_SPEC( x)"
\fBValue:\fP
.nf
(_LV_COORD_TYPE(x) == _LV_COORD_TYPE_SPEC ? true : false)
.PP
.fi

.SS "#define LV_COORD_SET_SPEC( x)"
\fBValue:\fP
.nf
((x) | _LV_COORD_TYPE_SPEC)
.PP
.fi

.SS "#define LV_PCT( x)"
\fBValue:\fP
.nf
(x < 0 ? LV_COORD_SET_SPEC(1000 \- (x)) : LV_COORD_SET_SPEC(x))
.PP
.fi

.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"
Alignments 
.SH "Function Documentation"
.PP 
.SS "bool _lv_area_intersect (\fBlv_area_t\fP * res_p, const \fBlv_area_t\fP * a1_p, const \fBlv_area_t\fP * a2_p)"
Get the common parts of two areas 
.PP
\fBParameters\fP
.RS 4
\fIres_p\fP pointer to an area, the result will be stored her 
.br
\fIa1_p\fP pointer to the first area 
.br
\fIa2_p\fP pointer to the second area 
.RE
.PP
\fBReturns\fP
.RS 4
false: the two area has NO common parts, res_p is invalid 
.RE
.PP

.SS "bool _lv_area_is_equal (const \fBlv_area_t\fP * a, const \fBlv_area_t\fP * b)"
Check if 2 area is the same 
.PP
\fBParameters\fP
.RS 4
\fIa\fP pointer to an area 
.br
\fIb\fP pointer to another area 
.RE
.PP

.SS "bool _lv_area_is_in (const \fBlv_area_t\fP * ain_p, const \fBlv_area_t\fP * aholder_p, lv_coord_t radius)"
Check if an area is fully on an other 
.PP
\fBParameters\fP
.RS 4
\fIain_p\fP pointer to an area which could be in 'aholder_p' 
.br
\fIaholder_p\fP pointer to an area which could involve 'ain_p' 
.br
\fIradius\fP radius of \fRaholder_p\fP (e\&.g\&. for rounded rectangle) 
.RE
.PP
\fBReturns\fP
.RS 4
true: \fRain_p\fP is fully inside \fRaholder_p\fP 
.RE
.PP

.SS "bool _lv_area_is_on (const \fBlv_area_t\fP * a1_p, const \fBlv_area_t\fP * a2_p)"
Check if two area has common parts 
.PP
\fBParameters\fP
.RS 4
\fIa1_p\fP pointer to an area\&. 
.br
\fIa2_p\fP pointer to an other area 
.RE
.PP
\fBReturns\fP
.RS 4
false: a1_p and a2_p has no common parts 
.RE
.PP

.SS "bool _lv_area_is_out (const \fBlv_area_t\fP * aout_p, const \fBlv_area_t\fP * aholder_p, lv_coord_t radius)"
Check if an area is fully out of an other 
.PP
\fBParameters\fP
.RS 4
\fIaout_p\fP pointer to an area which could be in 'aholder_p' 
.br
\fIaholder_p\fP pointer to an area which could involve 'ain_p' 
.br
\fIradius\fP radius of \fRaholder_p\fP (e\&.g\&. for rounded rectangle) 
.RE
.PP
\fBReturns\fP
.RS 4
true: \fRaout_p\fP is fully outside \fRaholder_p\fP 
.RE
.PP

.SS "bool _lv_area_is_point_on (const \fBlv_area_t\fP * a_p, const \fBlv_point_t\fP * p_p, lv_coord_t radius)"
Check if a point is on an area 
.PP
\fBParameters\fP
.RS 4
\fIa_p\fP pointer to an area 
.br
\fIp_p\fP pointer to a point 
.br
\fIradius\fP radius of area (e\&.g\&. for rounded rectangle) 
.RE
.PP
\fBReturns\fP
.RS 4
false:the point is out of the area 
.RE
.PP

.SS "void _lv_area_join (\fBlv_area_t\fP * a_res_p, const \fBlv_area_t\fP * a1_p, const \fBlv_area_t\fP * a2_p)"
Join two areas into a third which involves the other two 
.PP
\fBParameters\fP
.RS 4
\fIres_p\fP pointer to an area, the result will be stored here 
.br
\fIa1_p\fP pointer to the first area 
.br
\fIa2_p\fP pointer to the second area 
.RE
.PP

.SS "void _lv_area_set_pos (\fBlv_area_t\fP * area_p, lv_coord_t x, lv_coord_t y)"
Set the position of an area (width and height will be kept) 
.PP
\fBParameters\fP
.RS 4
\fIarea_p\fP pointer to an area 
.br
\fIx\fP the new x coordinate of the area 
.br
\fIy\fP the new y coordinate of the area 
.RE
.PP

.SS "void lv_area_align (const \fBlv_area_t\fP * base, \fBlv_area_t\fP * to_align, lv_align_t align, lv_coord_t ofs_x, lv_coord_t ofs_y)"
Align an area to an other 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP an are where the other will be aligned 
.br
\fIto_align\fP the area to align 
.br
\fIalign\fP \fRLV_ALIGN_\&.\&.\&.\fP 
.RE
.PP

.SS "uint32_t lv_area_get_size (const \fBlv_area_t\fP * area_p)"
Return with area of an area (x * y) 
.PP
\fBParameters\fP
.RS 4
\fIarea_p\fP pointer to an area 
.RE
.PP
\fBReturns\fP
.RS 4
size of area 
.RE
.PP

.SS "void lv_area_set (\fBlv_area_t\fP * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)"
Initialize an area 
.PP
\fBParameters\fP
.RS 4
\fIarea_p\fP pointer to an area 
.br
\fIx1\fP left coordinate of the area 
.br
\fIy1\fP top coordinate of the area 
.br
\fIx2\fP right coordinate of the area 
.br
\fIy2\fP bottom coordinate of the area 
.RE
.PP

.SS "void lv_area_set_height (\fBlv_area_t\fP * area_p, lv_coord_t h)"
Set the height of an area 
.PP
\fBParameters\fP
.RS 4
\fIarea_p\fP pointer to an area 
.br
\fIh\fP the new height of the area (h == 1 makes y1 == y2) 
.RE
.PP

.SS "void lv_area_set_width (\fBlv_area_t\fP * area_p, lv_coord_t w)"
Set the width of an area 
.PP
\fBParameters\fP
.RS 4
\fIarea_p\fP pointer to an area 
.br
\fIw\fP the new width of the area (w == 1 makes x1 == x2) 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
