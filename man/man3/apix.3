.TH "apix" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
apix \- Extended API
.SH SYNOPSIS
.br
.PP
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBapix\&.h\fP"
.br
.in -1c
.SS "RTOS Facilities"

.in +1c
.ti -1c
.RI "typedef void * \fBqueue_t\fP"
.br
.ti -1c
.RI "typedef void * \fBsem_t\fP"
.br
.ti -1c
.RI "bool \fBtask_abort_delay\fP (\fBtask_t\fP task)"
.br
.ti -1c
.RI "void \fBtask_notify_when_deleting\fP (\fBtask_t\fP target_task, \fBtask_t\fP task_to_notify, uint32_t value, \fBnotify_action_e_t\fP notify_action)"
.br
.ti -1c
.RI "\fBmutex_t\fP \fBmutex_recursive_create\fP (void)"
.br
.ti -1c
.RI "bool \fBmutex_recursive_take\fP (\fBmutex_t\fP mutex, uint32_t timeout)"
.br
.ti -1c
.RI "bool \fBmutex_recursive_give\fP (\fBmutex_t\fP mutex)"
.br
.ti -1c
.RI "\fBtask_t\fP \fBmutex_get_owner\fP (\fBmutex_t\fP mutex)"
.br
.ti -1c
.RI "sem_t \fBsem_create\fP (uint32_t max_count, uint32_t init_count)"
.br
.ti -1c
.RI "void \fBsem_delete\fP (sem_t sem)"
.br
.ti -1c
.RI "sem_t \fBsem_binary_create\fP (void)"
.br
.ti -1c
.RI "bool \fBsem_wait\fP (sem_t sem, uint32_t timeout)"
.br
.ti -1c
.RI "bool \fBsem_post\fP (sem_t sem)"
.br
.ti -1c
.RI "uint32_t \fBsem_get_count\fP (sem_t sem)"
.br
.ti -1c
.RI "queue_t \fBqueue_create\fP (uint32_t length, uint32_t item_size)"
.br
.ti -1c
.RI "bool \fBqueue_append\fP (queue_t queue, const void *item, uint32_t timeout)"
.br
.ti -1c
.RI "bool \fBqueue_peek\fP (queue_t queue, void *const buffer, uint32_t timeout)"
.br
.ti -1c
.RI "bool \fBqueue_recv\fP (queue_t queue, void *const buffer, uint32_t timeout)"
.br
.ti -1c
.RI "uint32_t \fBqueue_get_waiting\fP (const queue_t queue)"
.br
.ti -1c
.RI "uint32_t \fBqueue_get_available\fP (const queue_t queue)"
.br
.ti -1c
.RI "void \fBqueue_delete\fP (queue_t queue)"
.br
.ti -1c
.RI "void \fBqueue_reset\fP (queue_t queue)"
.br
.in -1c
.SS "Device Registration"

.in +1c
.ti -1c
.RI "int \fBregistry_bind_port\fP (uint8_t port, v5_device_e_t device_type)"
.br
.ti -1c
.RI "int \fBregistry_unbind_port\fP (uint8_t port)"
.br
.ti -1c
.RI "v5_device_e_t \fBregistry_get_bound_type\fP (uint8_t port)"
.br
.ti -1c
.RI "v5_device_e_t \fBregistry_get_plugged_type\fP (uint8_t port)"
.br
.in -1c
.SS "Filesystem"

.in +1c
.ti -1c
.RI "int32_t \fBfdctl\fP (int file, const uint32_t action, void *const extra_arg)"
.br
.ti -1c
.RI "int32_t \fBmotor_set_reversed\fP (int8_t port, const bool reverse)"
.br
.ti -1c
.RI "int32_t \fBmotor_is_reversed\fP (int8_t port)"
.br
.ti -1c
.RI "#define \fBSERCTL_ACTIVATE\fP   10"
.br
.ti -1c
.RI "#define \fBSERCTL_DEACTIVATE\fP   11"
.br
.ti -1c
.RI "#define \fBSERCTL_BLKWRITE\fP   12"
.br
.ti -1c
.RI "#define \fBSERCTL_NOBLKWRITE\fP   13"
.br
.ti -1c
.RI "#define \fBSERCTL_ENABLE_COBS\fP   14"
.br
.ti -1c
.RI "#define \fBSERCTL_DISABLE_COBS\fP   15"
.br
.ti -1c
.RI "#define \fBDEVCTL_FIONREAD\fP   16"
.br
.ti -1c
.RI "#define \fBDEVCTL_FIONWRITE\fP   18"
.br
.ti -1c
.RI "#define \fBDEVCTL_SET_BAUDRATE\fP   17"
.br
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBNote\fP
.RS 4
Also included in the Extended API is \fRLVGL\&.\fP
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define DEVCTL_FIONREAD   16"
Action macro to check if there is data available from the Generic Serial Device 
.SS "#define DEVCTL_FIONWRITE   18"
Action macro to check if there is space available in the Generic Serial Device's output buffer 
.SS "#define DEVCTL_SET_BAUDRATE   17"
Action macro to set the Generic Serial Device's baudrate\&.

.PP
The extra argument is the baudrate\&. 
.SS "#define SERCTL_ACTIVATE   10"
Action macro to pass into serctl or fdctl that activates the stream identifier\&.

.PP
When used with serctl, the extra argument must be the little endian representation of the stream identifier (e\&.g\&. "sout" -> 0x74756f73) 
.SS "#define SERCTL_BLKWRITE   12"
Action macro to pass into fdctl that enables blocking writes for the file

.PP
The extra argument is not used with this action, provide any value (e\&.g\&. NULL) instead 
.SS "#define SERCTL_DEACTIVATE   11"
Action macro to pass into serctl or fdctl that deactivates the stream identifier\&.

.PP
When used with serctl, the extra argument must be the little endian representation of the stream identifier (e\&.g\&. "sout" -> 0x74756f73) 
.SS "#define SERCTL_DISABLE_COBS   15"
Action macro to pass into serctl that disables advanced stream multiplexing capabilities

.PP
The extra argument is not used with this action, provide any value (e\&.g\&. NULL) instead 
.SS "#define SERCTL_ENABLE_COBS   14"
Action macro to pass into serctl that enables advanced stream multiplexing capabilities

.PP
The extra argument is not used with this action, provide any value (e\&.g\&. NULL) instead 
.SS "#define SERCTL_NOBLKWRITE   13"
Action macro to pass into fdctl that makes writes non-blocking for the file

.PP
The extra argument is not used with this action, provide any value (e\&.g\&. NULL) instead 
.SH "Function Documentation"
.PP 
.SS "int32_t fdctl (int file, const uint32_t action, void *const extra_arg)"
Control settings of the serial driver\&.

.PP
\fBParameters\fP
.RS 4
\fIaction\fP An action to perform on the serial driver\&. See the SERCTL_* macros for details on the different actions\&. 
.br
\fIextra_arg\fP An argument to pass in based on the action
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t motor_is_reversed (int8_t port)"
Gets the operation direction of the motor as set by the user\&.

.PP
This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (1-21)\&. ENODEV - The port cannot be configured as a motor

.PP
\fBParameters\fP
.RS 4
\fIport\fP The V5 port number from 1-21
.RE
.PP
\fBReturns\fP
.RS 4
1 if the motor has been reversed and 0 if the motor was not reversed, or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "int32_t motor_set_reversed (int8_t port, const bool reverse)"
Sets the reverse flag for the motor\&.

.PP
This will invert its movements and the values returned for its position\&.

.PP
This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (1-21)\&. ENODEV - The port cannot be configured as a motor

.PP
\fBParameters\fP
.RS 4
\fIport\fP The V5 port number from 1-21 
.br
\fIreverse\fP True reverses the motor, false is default
.RE
.PP
\fBReturns\fP
.RS 4
1 if the operation was successful or PROS_ERR if the operation failed, setting errno\&.
.RE
.PP
\fBExample\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBtask_t\fP mutex_get_owner (\fBmutex_t\fP mutex)"
Returns a handle to the current owner of a mutex\&.

.PP
\fBParameters\fP
.RS 4
\fImutex\fP A mutex handle
.RE
.PP
\fBReturns\fP
.RS 4
A handle to the current task that owns the mutex, or NULL if the mutex isn't owned\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "\fBmutex_t\fP mutex_recursive_create (void )"
Creates a recursive mutex which can be locked recursively by the owner\&.

.PP
\fBReturns\fP
.RS 4
A newly created recursive mutex\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool mutex_recursive_give (\fBmutex_t\fP mutex)"
Gives a recursive mutex\&.

.PP
\fBParameters\fP
.RS 4
\fImutex\fP A mutex handle created by mutex_recursive_create
.RE
.PP
\fBReturns\fP
.RS 4
1 if the mutex was obtained, 0 otherwise
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool mutex_recursive_take (\fBmutex_t\fP mutex, uint32_t timeout)"
Takes a recursive mutex\&.

.PP
\fBParameters\fP
.RS 4
\fImutex\fP A mutex handle created by mutex_recursive_create 
.br
\fIwait_time\fP Amount of time to wait before timing out
.RE
.PP
\fBReturns\fP
.RS 4
1 if the mutex was obtained, 0 otherwise
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool queue_append (queue_t queue, const void * item, uint32_t timeout)"
Posts an item to the front of a queue\&. The item is queued by copy, not by reference\&.

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP The queue handle 
.br
\fIitem\fP A pointer to the item that will be placed on the queue\&. 
.br
\fItimeout\fP Time to wait for space to become available\&. A timeout of 0 can be used to attempt to post without blocking\&. TIMEOUT_MAX can be used to block indefinitely\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if the item was preprended, false otherwise\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "queue_t queue_create (uint32_t length, uint32_t item_size)"
Creates a queue\&.

.PP
\fBParameters\fP
.RS 4
\fIlength\fP The maximum number of items that the queue can contain\&. 
.br
\fIitem_size\fP The number of bytes each item in the queue will require\&.
.RE
.PP
\fBReturns\fP
.RS 4
A handle to a newly created queue, or NULL if the queue cannot be created\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "void queue_delete (queue_t queue)"
Delete a queue\&.

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP Queue handle to delete
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t queue_get_available (const queue_t queue)"
Return the number of spaces left in a queue\&.

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP The queue handle\&.
.RE
.PP
\fBReturns\fP
.RS 4
The number of spaces available in the queue\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t queue_get_waiting (const queue_t queue)"
Return the number of messages stored in a queue\&.

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP The queue handle\&.
.RE
.PP
\fBReturns\fP
.RS 4
The number of messages available in the queue\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool queue_peek (queue_t queue, void *const buffer, uint32_t timeout)"
Receive an item from a queue without removing the item from the queue\&.

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP The queue handle 
.br
\fIbuffer\fP Pointer to a buffer to which the received item will be copied 
.br
\fItimeout\fP The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call\&. TIMEOUT_MAX can be used to block indefinitely\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if an item was copied into the buffer, false otherwise\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool queue_recv (queue_t queue, void *const buffer, uint32_t timeout)"
Receive an item from the queue\&.

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP The queue handle 
.br
\fIbuffer\fP Pointer to a buffer to which the received item will be copied 
.br
\fItimeout\fP The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call\&. \fBqueue_recv()\fP will return immediately if timeout is zero and the queue is empty\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if an item was copied into the buffer, false otherwise\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "void queue_reset (queue_t queue)"
Resets a queue to an empty state

.PP
\fBParameters\fP
.RS 4
\fIqueue\fP Queue handle to reset
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "int registry_bind_port (uint8_t port, v5_device_e_t device_type)"
Registers a device in the given zero-indexed port

.PP
Registers a device of the given type in the given port into the registry, if that type of device is detected to be plugged in to that port\&.

.PP
This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20), or a a different device than specified is plugged in\&. EADDRINUSE - The port is already registered to another device\&.

.PP
\fBParameters\fP
.RS 4
\fIport\fP The port number to register the device 
.br
\fIdevice\fP The type of device to register
.RE
.PP
\fBReturns\fP
.RS 4
1 upon success, PROS_ERR upon failure
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "v5_device_e_t registry_get_bound_type (uint8_t port)"
Returns the type of device registered to the zero-indexed port\&.

.PP
This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20)\&.

.PP
\fBParameters\fP
.RS 4
\fIport\fP The V5 port number from 0-20
.RE
.PP
\fBReturns\fP
.RS 4
The type of device that is registered into the port (NOT what is plugged in)
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "v5_device_e_t registry_get_plugged_type (uint8_t port)"
Returns the type of the device plugged into the zero-indexed port\&.

.PP
This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20)\&.

.PP
\fBParameters\fP
.RS 4
\fIport\fP The V5 port number from 0-20
.RE
.PP
\fBReturns\fP
.RS 4
The type of device that is plugged into the port (NOT what is registered)
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "int registry_unbind_port (uint8_t port)"
Deregisters a devices from the given zero-indexed port

.PP
Removes the device registed in the given port, if there is one\&.

.PP
This function uses the following values of errno when an error state is reached: ENXIO - The given value is not within the range of V5 ports (0-20)\&.

.PP
\fBParameters\fP
.RS 4
\fIport\fP The port number to deregister
.RE
.PP
\fBReturns\fP
.RS 4
1 upon success, PROS_ERR upon failure
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "sem_t sem_binary_create (void )"
Creates a binary semaphore\&.

.PP
\fBReturns\fP
.RS 4
A newly created semaphore\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "sem_t sem_create (uint32_t max_count, uint32_t init_count)"
Creates a counting sempahore\&.

.PP
\fBParameters\fP
.RS 4
\fImax_count\fP The maximum count value that can be reached\&. 
.br
\fIinit_count\fP The initial count value assigned to the new semaphore\&.
.RE
.PP
\fBReturns\fP
.RS 4
A newly created semaphore\&. If an error occurred, NULL will be returned and errno can be checked for hints as to why sem_create failed\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "void sem_delete (sem_t sem)"
Deletes a semaphore (or binary semaphore)

.PP
\fBParameters\fP
.RS 4
\fIsem\fP Semaphore to delete
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "uint32_t sem_get_count (sem_t sem)"
Returns the current value of the semaphore\&.

.PP
\fBParameters\fP
.RS 4
\fIsem\fP A semaphore handle
.RE
.PP
\fBReturns\fP
.RS 4
The current value of the semaphore (e\&.g\&. the number of resources available)
.RE
.PP
\fBExample\fP of sem_get_count: 
.PP
.nf

.fi
.PP
 
.SS "bool sem_post (sem_t sem)"
Increments a semaphore's value\&.

.PP
\fBParameters\fP
.RS 4
\fIsem\fP Semaphore to post
.RE
.PP
\fBReturns\fP
.RS 4
True if the value was incremented, false otherwise\&. If false is returned, then errno is set with a hint about why the semaphore couldn't be taken\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool sem_wait (sem_t sem, uint32_t timeout)"
Waits for the semaphore's value to be greater than 0\&. If the value is already greater than 0, this function immediately returns\&.

.PP
\fBParameters\fP
.RS 4
\fIsem\fP Semaphore to wait on 
.br
\fItimeout\fP Time to wait before the semaphore's becomes available\&. A timeout of 0 can be used to poll the sempahore\&. TIMEOUT_MAX can be used to block indefinitely\&.
.RE
.PP
\fBReturns\fP
.RS 4
True if the semaphore was successfully take, false otherwise\&. If false is returned, then errno is set with a hint about why the sempahore couldn't be taken\&.
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "bool task_abort_delay (\fBtask_t\fP task)"
Unblocks a task in the Blocked state (e\&.g\&. waiting for a delay, on a semaphore, etc\&.)\&.

.PP
\fBParameters\fP
.RS 4
\fItask\fP The task to unblock
.RE
.PP
\fBReturns\fP
.RS 4
True if the task was unblocked, false otherwise
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SS "void task_notify_when_deleting (\fBtask_t\fP target_task, \fBtask_t\fP task_to_notify, uint32_t value, \fBnotify_action_e_t\fP notify_action)"
Notify a task when a target task is being deleted\&.

.PP
\fBParameters\fP
.RS 4
\fItarget_task\fP The task being watched for deletion 
.br
\fItask_to_notify\fP The task to notify when target_task is deleted 
.br
\fIvalue\fP The value to supply to task_notify_ext 
.br
\fInotify_action\fP The action to supply to task_notify_ext
.RE
.PP
\fBExample:\fP 
.PP
.nf

.fi
.PP
 
.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
