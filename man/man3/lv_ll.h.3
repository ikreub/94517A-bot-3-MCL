.TH "include/liblvgl/misc/lv_ll.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/misc/lv_ll.h
.SH SYNOPSIS
.br
.PP
\fR#include <stdint\&.h>\fP
.br
\fR#include <stddef\&.h>\fP
.br
\fR#include <stdbool\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBlv_ll_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_LV_LL_READ\fP(list,  i)"
.br
.ti -1c
.RI "#define \fB_LV_LL_READ_BACK\fP(list,  i)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef uint8_t \fBlv_ll_node_t\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fB_lv_ll_init\fP (\fBlv_ll_t\fP *ll_p, uint32_t node_size)"
.br
.ti -1c
.RI "void * \fB_lv_ll_ins_head\fP (\fBlv_ll_t\fP *ll_p)"
.br
.ti -1c
.RI "void * \fB_lv_ll_ins_prev\fP (\fBlv_ll_t\fP *ll_p, void *n_act)"
.br
.ti -1c
.RI "void * \fB_lv_ll_ins_tail\fP (\fBlv_ll_t\fP *ll_p)"
.br
.ti -1c
.RI "void \fB_lv_ll_remove\fP (\fBlv_ll_t\fP *ll_p, void *node_p)"
.br
.ti -1c
.RI "void \fB_lv_ll_clear\fP (\fBlv_ll_t\fP *ll_p)"
.br
.ti -1c
.RI "void \fB_lv_ll_chg_list\fP (\fBlv_ll_t\fP *ll_ori_p, \fBlv_ll_t\fP *ll_new_p, void *node, bool head)"
.br
.ti -1c
.RI "void * \fB_lv_ll_get_head\fP (const \fBlv_ll_t\fP *ll_p)"
.br
.ti -1c
.RI "void * \fB_lv_ll_get_tail\fP (const \fBlv_ll_t\fP *ll_p)"
.br
.ti -1c
.RI "void * \fB_lv_ll_get_next\fP (const \fBlv_ll_t\fP *ll_p, const void *n_act)"
.br
.ti -1c
.RI "void * \fB_lv_ll_get_prev\fP (const \fBlv_ll_t\fP *ll_p, const void *n_act)"
.br
.ti -1c
.RI "uint32_t \fB_lv_ll_get_len\fP (const \fBlv_ll_t\fP *ll_p)"
.br
.ti -1c
.RI "void \fB_lv_ll_move_before\fP (\fBlv_ll_t\fP *ll_p, void *n_act, void *n_after)"
.br
.ti -1c
.RI "bool \fB_lv_ll_is_empty\fP (\fBlv_ll_t\fP *ll_p)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Handle linked lists\&. The nodes are dynamically allocated by the 'lv_mem' module\&. 
.SH "Macro Definition Documentation"
.PP 
.SS "#define _LV_LL_READ( list,  i)"
\fBValue:\fP
.nf
for(i = _lv_ll_get_head(list); i != NULL; i = _lv_ll_get_next(list, i))
.PP
.fi

.SS "#define _LV_LL_READ_BACK( list,  i)"
\fBValue:\fP
.nf
for(i = _lv_ll_get_tail(list); i != NULL; i = _lv_ll_get_prev(list, i))
.PP
.fi

.SH "Typedef Documentation"
.PP 
.SS "typedef uint8_t \fBlv_ll_node_t\fP"
Dummy type to make handling easier 
.SH "Function Documentation"
.PP 
.SS "void _lv_ll_chg_list (\fBlv_ll_t\fP * ll_ori_p, \fBlv_ll_t\fP * ll_new_p, void * node, bool head)"
Move a node to a new linked list 
.PP
\fBParameters\fP
.RS 4
\fIll_ori_p\fP pointer to the original (old) linked list 
.br
\fIll_new_p\fP pointer to the new linked list 
.br
\fInode\fP pointer to a node 
.br
\fIhead\fP true: be the head in the new list false be the tail in the new list 
.RE
.PP

.SS "void _lv_ll_clear (\fBlv_ll_t\fP * ll_p)"
Remove and free all elements from a linked list\&. The list remain valid but become empty\&. 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.RE
.PP

.SS "void * _lv_ll_get_head (const \fBlv_ll_t\fP * ll_p)"
Return with head node of the linked list 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the head of 'll_p' 
.RE
.PP

.SS "uint32_t _lv_ll_get_len (const \fBlv_ll_t\fP * ll_p)"
Return the length of the linked list\&. 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.RE
.PP
\fBReturns\fP
.RS 4
length of the linked list 
.RE
.PP

.SS "void * _lv_ll_get_next (const \fBlv_ll_t\fP * ll_p, const void * n_act)"
Return with the pointer of the next node after 'n_act' 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.br
\fIn_act\fP pointer a node 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the next node 
.RE
.PP

.SS "void * _lv_ll_get_prev (const \fBlv_ll_t\fP * ll_p, const void * n_act)"
Return with the pointer of the previous node after 'n_act' 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.br
\fIn_act\fP pointer a node 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the previous node 
.RE
.PP

.SS "void * _lv_ll_get_tail (const \fBlv_ll_t\fP * ll_p)"
Return with tail node of the linked list 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the tail of 'll_p' 
.RE
.PP

.SS "void _lv_ll_init (\fBlv_ll_t\fP * ll_p, uint32_t node_size)"
Initialize linked list 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to \fBlv_ll_t\fP variable 
.br
\fInode_size\fP the size of 1 node in bytes 
.RE
.PP

.SS "void * _lv_ll_ins_head (\fBlv_ll_t\fP * ll_p)"
Add a new head to a linked list 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the new head 
.RE
.PP

.SS "void * _lv_ll_ins_prev (\fBlv_ll_t\fP * ll_p, void * n_act)"
Insert a new node in front of the n_act node 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.br
\fIn_act\fP pointer a node 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the new node 
.RE
.PP

.SS "void * _lv_ll_ins_tail (\fBlv_ll_t\fP * ll_p)"
Add a new tail to a linked list 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to linked list 
.RE
.PP
\fBReturns\fP
.RS 4
pointer to the new tail 
.RE
.PP

.SS "bool _lv_ll_is_empty (\fBlv_ll_t\fP * ll_p)"
Check if a linked list is empty 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to a linked list 
.RE
.PP
\fBReturns\fP
.RS 4
true: the linked list is empty; false: not empty 
.RE
.PP

.SS "void _lv_ll_move_before (\fBlv_ll_t\fP * ll_p, void * n_act, void * n_after)"
TODO 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP 
.br
\fIn1_p\fP 
.br
\fIn2_p\fP void lv_ll_swap(lv_ll_t * ll_p, void * n1_p, void * n2_p); Move a node before an other node in the same linked list 
.br
\fIll_p\fP pointer to a linked list 
.br
\fIn_act\fP pointer to node to move 
.br
\fIn_after\fP pointer to a node which should be after \fRn_act\fP 
.RE
.PP

.SS "void _lv_ll_remove (\fBlv_ll_t\fP * ll_p, void * node_p)"
Remove the node 'node_p' from 'll_p' linked list\&. It does not free the memory of node\&. 
.PP
\fBParameters\fP
.RS 4
\fIll_p\fP pointer to the linked list of 'node_p' 
.br
\fInode_p\fP pointer to node in 'll_p' linked list 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
