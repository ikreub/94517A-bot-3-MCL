.TH "okapi::AsyncMotionProfileController" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
okapi::AsyncMotionProfileController
.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBokapi::AsyncPositionController< std::string, PathfinderPoint >\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBAsyncMotionProfileController\fP (const \fBTimeUtil\fP &itimeUtil, const \fBPathfinderLimits\fP &ilimits, const std::shared_ptr< \fBChassisModel\fP > &imodel, const \fBChassisScales\fP &iscales, const \fBAbstractMotor::GearsetRatioPair\fP &ipair, const std::shared_ptr< \fBLogger\fP > &ilogger=\fBLogger::getDefaultLogger\fP())"
.br
.ti -1c
.RI "\fBAsyncMotionProfileController\fP (AsyncMotionProfileController &&other)=delete"
.br
.ti -1c
.RI "\fBAsyncMotionProfileController\fP & \fBoperator=\fP (\fBAsyncMotionProfileController\fP &&other)=delete"
.br
.ti -1c
.RI "void \fBgeneratePath\fP (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, const std::string &ipathId)"
.br
.ti -1c
.RI "void \fBgeneratePath\fP (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, const std::string &ipathId, const \fBPathfinderLimits\fP &ilimits)"
.br
.ti -1c
.RI "bool \fBremovePath\fP (const std::string &ipathId)"
.br
.ti -1c
.RI "std::vector< std::string > \fBgetPaths\fP ()"
.br
.ti -1c
.RI "void \fBsetTarget\fP (std::string ipathId) override"
.br
.ti -1c
.RI "void \fBsetTarget\fP (std::string ipathId, bool ibackwards, bool imirrored=false)"
.br
.ti -1c
.RI "void \fBcontrollerSet\fP (std::string ivalue) override"
.br
.ti -1c
.RI "std::string \fBgetTarget\fP () override"
.br
.ti -1c
.RI "std::string \fBgetProcessValue\fP () const override"
.br
.ti -1c
.RI "void \fBwaitUntilSettled\fP () override"
.br
.ti -1c
.RI "void \fBmoveTo\fP (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, bool ibackwards=false, bool imirrored=false)"
.br
.ti -1c
.RI "void \fBmoveTo\fP (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, const \fBPathfinderLimits\fP &ilimits, bool ibackwards=false, bool imirrored=false)"
.br
.ti -1c
.RI "\fBPathfinderPoint\fP \fBgetError\fP () const override"
.br
.ti -1c
.RI "bool \fBisSettled\fP () override"
.br
.ti -1c
.RI "void \fBreset\fP () override"
.br
.ti -1c
.RI "void \fBflipDisable\fP () override"
.br
.ti -1c
.RI "void \fBflipDisable\fP (bool iisDisabled) override"
.br
.ti -1c
.RI "bool \fBisDisabled\fP () const override"
.br
.ti -1c
.RI "void \fBtarePosition\fP () override"
.br
.ti -1c
.RI "void \fBsetMaxVelocity\fP (std::int32_t imaxVelocity) override"
.br
.ti -1c
.RI "void \fBstartThread\fP ()"
.br
.ti -1c
.RI "\fBCrossplatformThread\fP * \fBgetThread\fP () const"
.br
.ti -1c
.RI "void \fBstorePath\fP (const std::string &idirectory, const std::string &ipathId)"
.br
.ti -1c
.RI "void \fBloadPath\fP (const std::string &idirectory, const std::string &ipathId)"
.br
.ti -1c
.RI "void \fBforceRemovePath\fP (const std::string &ipathId)"
.br
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBloop\fP ()"
.br
.ti -1c
.RI "virtual void \fBexecuteSinglePath\fP (const std::vector< \fBsquiggles::ProfilePoint\fP > &path, std::unique_ptr< \fBAbstractRate\fP > rate)"
.br
.ti -1c
.RI "QAngularSpeed \fBconvertLinearToRotational\fP (QSpeed linear) const"
.br
.ti -1c
.RI "std::string \fBgetPathErrorMessage\fP (const std::vector< \fBPathfinderPoint\fP > &points, const std::string &ipathId, int length)"
.br
.ti -1c
.RI "void \fBinternalStorePath\fP (std::ostream &file, const std::string &ipathId)"
.br
.ti -1c
.RI "void \fBinternalLoadPath\fP (std::istream &file, const std::string &ipathId)"
.br
.ti -1c
.RI "void \fBinternalLoadPathfinderPath\fP (std::istream &leftFile, std::istream &rightFile, const std::string &ipathId)"
.br
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static void \fBtrampoline\fP (void *context)"
.br
.ti -1c
.RI "static std::string \fBmakeFilePath\fP (const std::string &directory, const std::string &filename)"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "std::shared_ptr< \fBLogger\fP > \fBlogger\fP"
.br
.ti -1c
.RI "std::map< std::string, std::vector< \fBsquiggles::ProfilePoint\fP > > \fBpaths\fP {}"
.br
.ti -1c
.RI "\fBPathfinderLimits\fP \fBlimits\fP"
.br
.ti -1c
.RI "std::shared_ptr< \fBChassisModel\fP > \fBmodel\fP"
.br
.ti -1c
.RI "\fBChassisScales\fP \fBscales\fP"
.br
.ti -1c
.RI "\fBAbstractMotor::GearsetRatioPair\fP \fBpair\fP"
.br
.ti -1c
.RI "\fBTimeUtil\fP \fBtimeUtil\fP"
.br
.ti -1c
.RI "\fBCrossplatformMutex\fP \fBcurrentPathMutex\fP"
.br
.ti -1c
.RI "std::string \fBcurrentPath\fP {''}"
.br
.ti -1c
.RI "std::atomic_bool \fBisRunning\fP {false}"
.br
.ti -1c
.RI "std::atomic_int \fBdirection\fP {1}"
.br
.ti -1c
.RI "std::atomic_bool \fBmirrored\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBdisabled\fP {false}"
.br
.ti -1c
.RI "std::atomic_bool \fBdtorCalled\fP {false}"
.br
.ti -1c
.RI "\fBCrossplatformThread\fP * \fBtask\fP {nullptr}"
.br
.in -1c
.SS "Static Protected Attributes"

.in +1c
.ti -1c
.RI "static constexpr double \fBDT\fP = 0\&.01"
.br
.in -1c
.SH "Constructor & Destructor Documentation"
.PP 
.SS "okapi::AsyncMotionProfileController::AsyncMotionProfileController (const \fBTimeUtil\fP & itimeUtil, const \fBPathfinderLimits\fP & ilimits, const std::shared_ptr< \fBChassisModel\fP > & imodel, const \fBChassisScales\fP & iscales, const \fBAbstractMotor::GearsetRatioPair\fP & ipair, const std::shared_ptr< \fBLogger\fP > & ilogger = \fR\fBLogger::getDefaultLogger\fP()\fP)"
An Async \fBController\fP which generates and follows 2D motion profiles\&. Throws a \fRstd::invalid_argument\fP exception if the gear ratio is zero\&.

.PP
\fBParameters\fP
.RS 4
\fIitimeUtil\fP The \fBTimeUtil\fP\&. 
.br
\fIilimits\fP The default limits\&. 
.br
\fIimodel\fP The chassis model to control\&. 
.br
\fIiscales\fP The chassis dimensions\&. 
.br
\fIipair\fP The gearset\&. 
.br
\fIilogger\fP The logger this instance will log to\&. 
.RE
.PP

.SH "Member Function Documentation"
.PP 
.SS "void okapi::AsyncMotionProfileController::controllerSet (std::string ivalue)\fR [override]\fP, \fR [virtual]\fP"
Writes the value of the controller output\&. This method might be automatically called in another thread by the controller\&. This just calls \fR\fBsetTarget()\fP\fP\&. 
.PP
Implements \fBokapi::ControllerOutput< std::string >\fP\&.
.SS "QAngularSpeed okapi::AsyncMotionProfileController::convertLinearToRotational (QSpeed linear) const\fR [protected]\fP"
Converts linear chassis speed to rotational motor speed\&.

.PP
\fBParameters\fP
.RS 4
\fIlinear\fP chassis frame speed 
.RE
.PP
\fBReturns\fP
.RS 4
motor frame speed 
.RE
.PP

.SS "virtual void okapi::AsyncMotionProfileController::executeSinglePath (const std::vector< \fBsquiggles::ProfilePoint\fP > & path, std::unique_ptr< \fBAbstractRate\fP > rate)\fR [protected]\fP, \fR [virtual]\fP"
Follow the supplied path\&. Must follow the disabled lifecycle\&. 
.SS "void okapi::AsyncMotionProfileController::flipDisable ()\fR [override]\fP, \fR [virtual]\fP"
Changes whether the controller is off or on\&. Turning the controller on after it was off will NOT cause the controller to move to its last set target\&. 
.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "void okapi::AsyncMotionProfileController::flipDisable (bool iisDisabled)\fR [override]\fP"
Sets whether the controller is off or on\&. Turning the controller on after it was off will NOT cause the controller to move to its last set target, unless it was reset in that time\&.

.PP
\fBParameters\fP
.RS 4
\fIiisDisabled\fP whether the controller is disabled 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::forceRemovePath (const std::string & ipathId)"
Attempts to remove a path without stopping execution\&. If that fails, disables the controller and removes the path\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP The path ID that will be removed 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::generatePath (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, const std::string & ipathId)"
Generates a path which intersects the given waypoints and saves it internally with a key of pathId\&. Call \fRexecutePath()\fP with the same pathId to run it\&.

.PP
If the waypoints form a path which is impossible to achieve, an instance of \fRstd::runtime_error\fP is thrown (and an error is logged) which describes the waypoints\&. If there are no waypoints, no path is generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiwaypoints\fP The waypoints to hit on the path\&. 
.br
\fIipathId\fP A unique identifier to save the path with\&. 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::generatePath (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, const std::string & ipathId, const \fBPathfinderLimits\fP & ilimits)"
Generates a path which intersects the given waypoints and saves it internally with a key of pathId\&. Call \fRexecutePath()\fP with the same pathId to run it\&.

.PP
If the waypoints form a path which is impossible to achieve, an instance of \fRstd::runtime_error\fP is thrown (and an error is logged) which describes the waypoints\&. If there are no waypoints, no path is generated\&.

.PP
NOTE: The waypoints are expected to be in the okapi::State::FRAME_TRANSFORMATION format where +x is forward, +y is right, and 0 theta is measured from the +x axis to the +y axis\&.

.PP
\fBParameters\fP
.RS 4
\fIiwaypoints\fP The waypoints to hit on the path\&. 
.br
\fIipathId\fP A unique identifier to save the path with\&. 
.br
\fIilimits\fP The limits to use for this path only\&. 
.RE
.PP

.SS "\fBPathfinderPoint\fP okapi::AsyncMotionProfileController::getError () const\fR [override]\fP, \fR [virtual]\fP"
Returns the last error of the controller\&. Does not update when disabled\&. This implementation always returns zero since the robot is assumed to perfectly follow the path\&. Subclasses can override this to be more accurate using odometry information\&.

.PP
\fBReturns\fP
.RS 4
the last error 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "std::vector< std::string > okapi::AsyncMotionProfileController::getPaths ()"
Gets the identifiers of all paths saved in this \fR\fBAsyncMotionProfileController\fP\fP\&.

.PP
\fBReturns\fP
.RS 4
The identifiers of all paths 
.RE
.PP

.SS "std::string okapi::AsyncMotionProfileController::getProcessValue () const\fR [override]\fP, \fR [virtual]\fP"
This is overridden to return the current path\&.

.PP
\fBReturns\fP
.RS 4
The most recent value of the process variable\&. 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "std::string okapi::AsyncMotionProfileController::getTarget ()\fR [override]\fP, \fR [virtual]\fP"
Gets the last set target, or the default target if none was set\&.

.PP
\fBReturns\fP
.RS 4
the last target 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "\fBCrossplatformThread\fP * okapi::AsyncMotionProfileController::getThread () const"

.PP
\fBReturns\fP
.RS 4
The underlying thread handle\&. 
.RE
.PP

.SS "bool okapi::AsyncMotionProfileController::isDisabled () const\fR [override]\fP, \fR [virtual]\fP"
Returns whether the controller is currently disabled\&.

.PP
\fBReturns\fP
.RS 4
whether the controller is currently disabled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "bool okapi::AsyncMotionProfileController::isSettled ()\fR [override]\fP, \fR [virtual]\fP"
Returns whether the controller has settled at the target\&. Determining what settling means is implementation-dependent\&.

.PP
If the controller is disabled, this method must return true\&.

.PP
\fBReturns\fP
.RS 4
whether the controller is settled 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "void okapi::AsyncMotionProfileController::loadPath (const std::string & idirectory, const std::string & ipathId)"
Loads a path from a directory on the SD card containing a path CSV file\&. \fR/usd/\fP is automatically prepended to \fRidirectory\fP if it is not specified\&.

.PP
\fBParameters\fP
.RS 4
\fIidirectory\fP The directory that the path files are stored in 
.br
\fIipathId\fP The path ID that the paths are stored under (and will be loaded into) 
.RE
.PP

.SS "std::string okapi::AsyncMotionProfileController::makeFilePath (const std::string & directory, const std::string & filename)\fR [static]\fP, \fR [protected]\fP"
Joins and escapes a directory and file name

.PP
\fBParameters\fP
.RS 4
\fIdirectory\fP The directory path, separated by forward slashes (/) and with or without a trailing slash 
.br
\fIfilename\fP The file name in the directory 
.RE
.PP
\fBReturns\fP
.RS 4
the fully qualified and legal path name 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::moveTo (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, bool ibackwards = \fRfalse\fP, bool imirrored = \fRfalse\fP)"
Generates a new path from the position (typically the current position) to the target and blocks until the controller has settled\&. Does not save the path which was generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiwaypoints\fP The waypoints to hit on the path\&. 
.br
\fIibackwards\fP Whether to follow the profile backwards\&. 
.br
\fIimirrored\fP Whether to follow the profile mirrored\&. 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::moveTo (std::initializer_list< \fBPathfinderPoint\fP > iwaypoints, const \fBPathfinderLimits\fP & ilimits, bool ibackwards = \fRfalse\fP, bool imirrored = \fRfalse\fP)"
Generates a new path from the position (typically the current position) to the target and blocks until the controller has settled\&. Does not save the path which was generated\&.

.PP
\fBParameters\fP
.RS 4
\fIiwaypoints\fP The waypoints to hit on the path\&. 
.br
\fIilimits\fP The limits to use for this path only\&. 
.br
\fIibackwards\fP Whether to follow the profile backwards\&. 
.br
\fIimirrored\fP Whether to follow the profile mirrored\&. 
.RE
.PP

.SS "bool okapi::AsyncMotionProfileController::removePath (const std::string & ipathId)"
Removes a path and frees the memory it used\&. This function returns true if the path was either deleted or didn't exist in the first place\&. It returns false if the path could not be removed because it is running\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP A unique identifier for the path, previously passed to \fR\fBgeneratePath()\fP\fP 
.RE
.PP
\fBReturns\fP
.RS 4
True if the path no longer exists 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::reset ()\fR [override]\fP, \fR [virtual]\fP"
Resets the controller so it can start from 0 again properly\&. Keeps configuration from before\&. This implementation also stops movement\&. 
.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "void okapi::AsyncMotionProfileController::setMaxVelocity (std::int32_t imaxVelocity)\fR [override]\fP, \fR [virtual]\fP"
This implementation does nothing because the maximum velocity is configured using \fBPathfinderLimits\fP elsewhere\&.

.PP
\fBParameters\fP
.RS 4
\fIimaxVelocity\fP Ignored\&. 
.RE
.PP

.PP
Implements \fBokapi::AsyncPositionController< std::string, PathfinderPoint >\fP\&.
.SS "void okapi::AsyncMotionProfileController::setTarget (std::string ipathId)\fR [override]\fP, \fR [virtual]\fP"
Executes a path with the given ID\&. If there is no path matching the ID, the method will return\&. Any targets set while a path is being followed will be ignored\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP A unique identifier for the path, previously passed to \fR\fBgeneratePath()\fP\fP\&. 
.RE
.PP

.PP
Implements \fBokapi::ClosedLoopController< std::string, PathfinderPoint >\fP\&.
.SS "void okapi::AsyncMotionProfileController::setTarget (std::string ipathId, bool ibackwards, bool imirrored = \fRfalse\fP)"
Executes a path with the given ID\&. If there is no path matching the ID, the method will return\&. Any targets set while a path is being followed will be ignored\&.

.PP
\fBParameters\fP
.RS 4
\fIipathId\fP A unique identifier for the path, previously passed to \fR\fBgeneratePath()\fP\fP\&. 
.br
\fIibackwards\fP Whether to follow the profile backwards\&. 
.br
\fIimirrored\fP Whether to follow the profile mirrored\&. 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::startThread ()"
Starts the internal thread\&. This should not be called by normal users\&. This method is called by the \fR\fBAsyncMotionProfileControllerBuilder\fP\fP when making a new instance of this class\&. 
.SS "void okapi::AsyncMotionProfileController::storePath (const std::string & idirectory, const std::string & ipathId)"
Saves a generated path to a file\&. Paths are stored as \fR<ipathId>\&.csv\fP\&. An SD card must be inserted into the brain and the directory must exist\&. \fRidirectory\fP can be prefixed with \fR/usd/\fP, but it this is not required\&.

.PP
\fBParameters\fP
.RS 4
\fIidirectory\fP The directory to store the path file in 
.br
\fIipathId\fP The path ID of the generated path 
.RE
.PP

.SS "void okapi::AsyncMotionProfileController::tarePosition ()\fR [override]\fP, \fR [virtual]\fP"
This implementation does nothing because the API always requires the starting position to be specified\&. 
.PP
Implements \fBokapi::AsyncPositionController< std::string, PathfinderPoint >\fP\&.
.SS "void okapi::AsyncMotionProfileController::waitUntilSettled ()\fR [override]\fP, \fR [virtual]\fP"
Blocks the current task until the controller has settled\&. This controller is settled when it has finished following a path\&. If no path is being followed, it is settled\&. 
.PP
Implements \fBokapi::AsyncController< std::string, PathfinderPoint >\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
