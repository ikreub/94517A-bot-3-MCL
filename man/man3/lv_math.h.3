.TH "include/liblvgl/misc/lv_math.h" 3 "Version 1.0" "94517A bot #3 with DSR" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/liblvgl/misc/lv_math.h
.SH SYNOPSIS
.br
.PP
\fR#include 'liblvgl/lv_conf_internal\&.h'\fP
.br
\fR#include <stdint\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBlv_sqrt_res_t\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLV_TRIGO_SIN_MAX\fP   32767"
.br
.ti -1c
.RI "#define \fBLV_TRIGO_SHIFT\fP   15"
.br
.ti -1c
.RI "#define \fBLV_BEZIER_VAL_MAX\fP   1024"
.br
.ti -1c
.RI "#define \fBLV_BEZIER_VAL_SHIFT\fP   10"
.br
.ti -1c
.RI "#define \fBLV_MIN\fP(a,  b)"
.br
.ti -1c
.RI "#define \fBLV_MIN3\fP(a,  b,  c)"
.br
.ti -1c
.RI "#define \fBLV_MIN4\fP(a,  b,  c,  d)"
.br
.ti -1c
.RI "#define \fBLV_MAX\fP(a,  b)"
.br
.ti -1c
.RI "#define \fBLV_MAX3\fP(a,  b,  c)"
.br
.ti -1c
.RI "#define \fBLV_MAX4\fP(a,  b,  c,  d)"
.br
.ti -1c
.RI "#define \fBLV_CLAMP\fP(min,  val,  max)"
.br
.ti -1c
.RI "#define \fBLV_ABS\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_UDIV255\fP(x)"
.br
.ti -1c
.RI "#define \fBLV_IS_SIGNED\fP(t)"
.br
.ti -1c
.RI "#define \fBLV_UMAX_OF\fP(t)"
.br
.ti -1c
.RI "#define \fBLV_SMAX_OF\fP(t)"
.br
.ti -1c
.RI "#define \fBLV_MAX_OF\fP(t)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "uint32_t \fBlv_bezier3\fP (uint32_t t, uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)"
.br
.ti -1c
.RI "uint16_t \fBlv_atan2\fP (int x, int y)"
.br
.ti -1c
.RI "int64_t \fBlv_pow\fP (int64_t base, int8_t exp)"
.br
.ti -1c
.RI "int32_t \fBlv_map\fP (int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)"
.br
.ti -1c
.RI "uint32_t \fBlv_rand\fP (uint32_t min, uint32_t max)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define LV_ABS( x)"
\fBValue:\fP
.nf
((x) > 0 ? (x) : (\-(x)))
.PP
.fi

.SS "#define LV_BEZIER_VAL_MAX   1024"
Max time in Bezier functions (not [0\&.\&.1] to use integers) 
.SS "#define LV_BEZIER_VAL_SHIFT   10"
log2(LV_BEZIER_VAL_MAX): used to normalize up scaled values 
.SS "#define LV_CLAMP( min,  val,  max)"
\fBValue:\fP
.nf
(LV_MAX(min, (LV_MIN(val, max))))
.PP
.fi

.SS "#define LV_IS_SIGNED( t)"
\fBValue:\fP
.nf
(((t)(\-1)) < ((t)0))
.PP
.fi

.SS "#define LV_MAX( a,  b)"
\fBValue:\fP
.nf
((a) > (b) ? (a) : (b))
.PP
.fi

.SS "#define LV_MAX3( a,  b,  c)"
\fBValue:\fP
.nf
(LV_MAX(LV_MAX(a,b), c))
.PP
.fi

.SS "#define LV_MAX4( a,  b,  c,  d)"
\fBValue:\fP
.nf
(LV_MAX(LV_MAX(a,b), LV_MAX(c,d)))
.PP
.fi

.SS "#define LV_MAX_OF( t)"
\fBValue:\fP
.nf
((unsigned long)(LV_IS_SIGNED(t) ? LV_SMAX_OF(t) : LV_UMAX_OF(t)))
.PP
.fi

.SS "#define LV_MIN( a,  b)"
\fBValue:\fP
.nf
((a) < (b) ? (a) : (b))
.PP
.fi

.SS "#define LV_MIN3( a,  b,  c)"
\fBValue:\fP
.nf
(LV_MIN(LV_MIN(a,b), c))
.PP
.fi

.SS "#define LV_MIN4( a,  b,  c,  d)"
\fBValue:\fP
.nf
(LV_MIN(LV_MIN(a,b), LV_MIN(c,d)))
.PP
.fi

.SS "#define LV_SMAX_OF( t)"
\fBValue:\fP
.nf
(((0x1ULL << ((sizeof(t) * 8ULL) \- 1ULL)) \- 1ULL) | (0x7ULL << ((sizeof(t) * 8ULL) \- 4ULL)))
.PP
.fi

.SS "#define LV_TRIGO_SHIFT   15"

.PP
.RS 4

.PP
.RS 4
LV_TRIGO_SHIFT to normalize 
.RE
.PP
.RE
.PP

.SS "#define LV_UDIV255( x)"
\fBValue:\fP
.nf
(((x) * 0x8081U) >> 0x17)
.PP
.fi

.SS "#define LV_UMAX_OF( t)"
\fBValue:\fP
.nf
(((0x1ULL << ((sizeof(t) * 8ULL) \- 1ULL)) \- 1ULL) | (0xFULL << ((sizeof(t) * 8ULL) \- 4ULL)))
.PP
.fi

.SH "Function Documentation"
.PP 
.SS "uint16_t lv_atan2 (int x, int y)"
Calculate the atan2 of a vector\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP 
.br
\fIy\fP 
.RE
.PP
\fBReturns\fP
.RS 4
the angle in degree calculated from the given parameters in range of [0\&.\&.360] 
.RE
.PP

.SS "uint32_t lv_bezier3 (uint32_t t, uint32_t u0, uint32_t u1, uint32_t u2, uint32_t u3)"
Calculate a value of a Cubic Bezier function\&. 
.PP
\fBParameters\fP
.RS 4
\fIt\fP time in range of [0\&.\&.LV_BEZIER_VAL_MAX] 
.br
\fIu0\fP start values in range of [0\&.\&.LV_BEZIER_VAL_MAX] 
.br
\fIu1\fP control value 1 values in range of [0\&.\&.LV_BEZIER_VAL_MAX] 
.br
\fIu2\fP control value 2 in range of [0\&.\&.LV_BEZIER_VAL_MAX] 
.br
\fIu3\fP end values in range of [0\&.\&.LV_BEZIER_VAL_MAX] 
.RE
.PP
\fBReturns\fP
.RS 4
the value calculated from the given parameters in range of [0\&.\&.LV_BEZIER_VAL_MAX] 
.RE
.PP

.SS "int32_t lv_map (int32_t x, int32_t min_in, int32_t max_in, int32_t min_out, int32_t max_out)"
Get the mapped of a number given an input and output range 
.PP
\fBParameters\fP
.RS 4
\fIx\fP integer which mapped value should be calculated 
.br
\fImin_in\fP min input range 
.br
\fImax_in\fP max input range 
.br
\fImin_out\fP max output range 
.br
\fImax_out\fP max output range 
.RE
.PP
\fBReturns\fP
.RS 4
the mapped number 
.RE
.PP

.SS "int64_t lv_pow (int64_t base, int8_t exp)"
Calculate the integer exponents\&. 
.PP
\fBParameters\fP
.RS 4
\fIbase\fP 
.br
\fIpower\fP 
.RE
.PP
\fBReturns\fP
.RS 4
base raised to the power exponent 
.RE
.PP

.SS "uint32_t lv_rand (uint32_t min, uint32_t max)"
Get a pseudo random number in the given range 
.PP
\fBParameters\fP
.RS 4
\fImin\fP the minimum value 
.br
\fImax\fP the maximum value 
.RE
.PP
\fBReturns\fP
.RS 4
return the random number\&. min <= return_value <= max 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for 94517A bot #3 with DSR from the source code\&.
